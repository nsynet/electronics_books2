C51 COMPILER V7.10   REG_RW                                                                09/17/2011 14:04:14 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE REG_RW
OBJECT MODULE PLACED IN Reg_RW.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Reg_RW.c OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************/
   2          //      版权所有：Copyright (c) 2005 - 2010 ICRoute INC.
   3          /************************************************************************************/
   4          
   5          #include "STC10F08XE.H"
   6          #include "Reg_RW.h"
   7          
   8          extern void _nop_(void);
   9          
  10          /************************************************************************************/
  11          //      主控MCU对于LD3320读写寄存器的实现有四种：
  12          //      #define SOFT_PARA_PORT          //      软件模拟并行读写
  13          //      #define HARD_PARA_PORT          //      硬件实现并行读写 （需要主控MCU有硬件的WR/RD端口）
  14          //      #define SOFT_SPI_PORT           //      软件模拟SPI读写
  15          //      #define HARD_SPI_PORT           //      硬件实现SPI读写   （需要主控MCU有硬件SPI接口）
  16          /************************************************************************************/
  17          
  18          
  19          #ifdef SOFT_PARA_PORT
              
                              #define DELAY_NOP       _nop_();_nop_();_nop_();
                              sbit    LD_WR   = P3^6;
                              sbit    LD_RD   = P3^7;
                              sbit    LD_CS   = P2^6;
                              sbit    LD_A0   = P2^0;
                              void LD_WriteReg( unsigned char address, unsigned char dataout )
                              {
                                      P0 = address;
                                      LD_A0 = 1;
                                      LD_CS = 0;
                                      LD_WR = 0;
                                      DELAY_NOP;
                              
                                      LD_WR = 1;
                                      LD_CS = 1;
                                      DELAY_NOP;
                              
                                      P0 = dataout;
                                      LD_A0 = 0;
                                      LD_CS = 0;
                                      LD_WR = 0;
                                      DELAY_NOP;
                              
                                      LD_WR = 1;
                                      LD_CS = 1;
                                      DELAY_NOP;
                              }
                              
                              unsigned char LD_ReadReg( unsigned char address )
                              {
                                      unsigned char datain;
                              
                                      P0 = address;
                                      LD_A0 = 1;
                                      LD_CS = 0;
C51 COMPILER V7.10   REG_RW                                                                09/17/2011 14:04:14 PAGE 2   

                                      LD_WR = 0;
                                      DELAY_NOP;
                              
                                      LD_WR = 1;
                                      LD_CS = 1;
                                      DELAY_NOP;
                              
                                      LD_A0 = 0;
                                      LD_CS = 0;
                                      LD_RD = 0;
                                      DELAY_NOP;
              
                                      datain = P0;
                                      LD_RD = 1;
                                      LD_CS = 1;
                                      DELAY_NOP;
                              
                                      return datain;
                              }
              #endif
  76          
  77          #ifdef HARD_PARA_PORT
              
                              #define LD_INDEX_PORT           (*((volatile unsigned char xdata*)(0x8100))) 
                              #define LD_DATA_PORT            (*((volatile unsigned char xdata*)(0x8000))) 
                              
                              //评估板上 MCU的A8 连接到 LD芯片的AD
                              //         MCU的A14 连接到 LD芯片的CSB
                              //         MCU的RD、WR 连接 LD芯片的RD、WR (xdata 读写时自动产生低信号)
                              //
                              //0x8100的二进制是10000001 00000000             CSB=0 AD=1
                              //                 ^     ^
                              //0x8000的二进制是10000000 00000000             CSB=0 AD=0
                              //                 ^     ^
                              
                              void LD_WriteReg( unsigned char address, unsigned char dataout )
                              {
                                      LD_INDEX_PORT  = address;         
                                      LD_DATA_PORT = dataout;          
                              }
                              
                              unsigned char LD_ReadReg( unsigned char address )
                              {
                                      LD_INDEX_PORT = address;         
                                      return (unsigned char)LD_DATA_PORT;     
                              }
              #endif
 103          
 104          #ifdef SOFT_SPI_PORT
 105                          #define DELAY_NOP       _nop_();_nop_();_nop_();
 106                          
 107                          sbit SCS=P2^6;    //芯片片选信号
 108                          sbit SDCK=P0^2;   //SPI 时钟信号
 109                          sbit SDI=P0^0;    //SPI 数据输入
 110                          sbit SDO=P0^1;    //SPI 数据输出
 111                          sbit SPIS=P3^6;   //SPI模式设置：低有效。
 112          
 113                          void LD_WriteReg(unsigned char address,unsigned char dataout)
 114                          {
 115   1                              unsigned char i = 0;
 116   1                              unsigned char command=0x04;
 117   1                              SPIS =0;
C51 COMPILER V7.10   REG_RW                                                                09/17/2011 14:04:14 PAGE 3   

 118   1                              SCS = 0;
 119   1                              DELAY_NOP;
 120   1                      
 121   1                              //write command
 122   1                              for (i=0;i < 8; i++)
 123   1                              {
 124   2                                      if ((command & 0x80) == 0x80) 
 125   2                                              SDI = 1;
 126   2                                      else
 127   2                                              SDI = 0;
 128   2                                      
 129   2                                      DELAY_NOP;
 130   2                                      SDCK = 0;
 131   2                                      command = (command << 1);  
 132   2                                      DELAY_NOP;
 133   2                                      SDCK = 1;  
 134   2                              }
 135   1                              //write address
 136   1                              for (i=0;i < 8; i++)
 137   1                              {
 138   2                                      if ((address & 0x80) == 0x80) 
 139   2                                              SDI = 1;
 140   2                                      else
 141   2                                              SDI = 0;
 142   2                                      DELAY_NOP;
 143   2                                      SDCK = 0;
 144   2                                      address = (address << 1); 
 145   2                                      DELAY_NOP;
 146   2                                      SDCK = 1;  
 147   2                              }
 148   1                              //write data
 149   1                              for (i=0;i < 8; i++)
 150   1                              {
 151   2                                      if ((dataout & 0x80) == 0x80) 
 152   2                                              SDI = 1;
 153   2                                      else
 154   2                                              SDI = 0;
 155   2                                      DELAY_NOP;
 156   2                                      SDCK = 0;
 157   2                                      dataout = (dataout << 1); 
 158   2                                      DELAY_NOP;
 159   2                                      SDCK = 1;  
 160   2                              }
 161   1                              DELAY_NOP;
 162   1                              SCS = 1;
 163   1                      }
 164          
 165                          unsigned char LD_ReadReg(unsigned char address)
 166                          {
 167   1                              unsigned char i = 0; 
 168   1                              unsigned char datain =0 ;
 169   1                              unsigned char temp = 0; 
 170   1                              unsigned char command=0x05;
 171   1                              SPIS =0;
 172   1                              SCS = 0;
 173   1                              DELAY_NOP;
 174   1                      
 175   1                              //write command
 176   1                              for (i=0;i < 8; i++)
 177   1                              {
 178   2                                      if ((command & 0x80) == 0x80) 
 179   2                                              SDI = 1;
C51 COMPILER V7.10   REG_RW                                                                09/17/2011 14:04:14 PAGE 4   

 180   2                                      else
 181   2                                              SDI = 0;
 182   2                                      DELAY_NOP;
 183   2                                      SDCK = 0;
 184   2                                      command = (command << 1);  
 185   2                                      DELAY_NOP;
 186   2                                      SDCK = 1;  
 187   2                              }
 188   1      
 189   1                              //write address
 190   1                              for (i=0;i < 8; i++)
 191   1                              {
 192   2                                      if ((address & 0x80) == 0x80) 
 193   2                                              SDI = 1;
 194   2                                      else
 195   2                                              SDI = 0;
 196   2                                      DELAY_NOP;
 197   2                                      SDCK = 0;
 198   2                                      address = (address << 1); 
 199   2                                      DELAY_NOP;
 200   2                                      SDCK = 1;  
 201   2                              }
 202   1                              DELAY_NOP;
 203   1      
 204   1                              //Read data
 205   1                              for (i=0;i < 8; i++)
 206   1                              {
 207   2                                      datain = (datain << 1);
 208   2                                      temp = SDO;
 209   2                                      DELAY_NOP;
 210   2                                      SDCK = 0;  
 211   2                                      if (temp == 1)  
 212   2                                              datain |= 0x01; 
 213   2                                      DELAY_NOP;
 214   2                                      SDCK = 1;  
 215   2                              }
 216   1                      
 217   1                              DELAY_NOP;
 218   1                              SCS = 1;
 219   1                              return datain;
 220   1                      }
 221          
 222          #endif
 223          
 224          #ifdef HARD_SPI_PORT
                              /*
                              STC单片机（带SPI口的种类）兼顾读写的函数例程
                              unsigend char SPI_TR( unsigned char x ) 
                              { 
                                      SPSTAT=0xC0;  
                                      SPDAT=x;  
                                      while(!(SPSTAT&0x80));  
                                      return SPDAT;
                              }
                              
                              --------------------------------------------------
                              AVR单片机（带SPI口的种类）兼顾读写的函数例程
                              unsigend char SPI_TR( unsigned char x ) 
                              { 
                                      SPDR=x;  
                                      while(!(SPSR & (1<<SPIF)));  
                                      return SPDR;
C51 COMPILER V7.10   REG_RW                                                                09/17/2011 14:04:14 PAGE 5   

                              }
              
                              */
                              void LD_WriteReg( unsigned char address, unsigned char dataout )
                              {
                                      // 这里添加硬件SPI口的操作代码：
                                      SPI_TR(0x04); // 发送 0x04
                                      SPI_TR(address); // 发送 address
                                      SPI_TR(dataout); // 发送 dataout
                              }
                              unsigned char LD_ReadReg( unsigned char address )
                              {
                                      // 这里添加硬件SPI口的操作代码：
                                      SPI_TR(0x05); // 发送 0x05
                                      SPI_TR(address); // 发送 address
                                      return (SPI_TR(0)); // 读出数据, 并返回
                              }
              #endif
 260          
 261          
 262          
 263          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    218    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
