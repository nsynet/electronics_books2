C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************/
   2          //  修改：九九新电子 2011-08-01   www.99xdz.com
   3          /************************************************************************************/
   4          
   5          #include "STC10F08XE.H"
   6          #include "LDchip.h"
   7          #include "Reg_RW.h"
   8          #include "FlashDef.h"
   9          #include "SubFuncs.h"
  10          
  11          
  12          /************************************************************************************/
  13          //      nAsrStatus 用来在main主程序中表示程序运行的状态，不是LD3320芯片内部的状态寄存器
  14          //      LD_ASR_NONE:            表示没有在作ASR识别
  15          //      LD_ASR_RUNING：         表示LD3320正在作ASR识别中
  16          //      LD_ASR_FOUNDOK:         表示一次识别流程结束后，有一个识别结果
  17          //      LD_ASR_FOUNDZERO:       表示一次识别流程结束后，没有识别结果
  18          //      LD_ASR_ERROR:           表示一次识别流程中LD3320芯片内部出现不正确的状态
  19          /***********************************************************************************/
  20          uint8 idata nAsrStatus=0;
  21                  
  22          #define Same_VOIC_COUNT  9              //定义长度和播放语音长度一致，用以判断返回值是否需要播放语音
  23          
  24          extern void          _nop_     (void);
  25          
  26          void MCU_init();
  27          void FlashLED(uint8 nTimes);
  28          void PlaySound(uint8 nCode);
  29          uint8 RunASR();
  30          void ProcessInt0();
  31          void UART_init();
  32          void OutputIO(uint8 nRes);
  33          void LED_TEST();
  34          
  35          /************************************************************************************/
  36          //      这个示范程序是基于STC10L08XE编译的完整地，可以执行的程序
  37          //      事先了识别和播放的功能
  38          //      根据用户说出不同的关键词语，识别后播放对应的mp3声音
  39          //
  40          //      与LD3320芯片有关的函数功能，都在"开发手册.pdf"中有详细说明
  41          //      请开发者对照"开发手册.pdf“阅读
  42          //      
  43          //      开发者在学习LD3320开始时，可以直接把在这个main函数拷贝到自己单片机中编译运行
  44          //      如果只实现ASR语音识别功能，可以把程序中PlaySound()函数的调用注释掉就可以
  45          //      
  46          //      当然，用户要根据自己实际的单片机去修改 mcu_init ，以及对应的管脚连接的定义，中断定义
  47          /************************************************************************************/
  48          
  49          void  main()
  50          {
  51   1              uint8 idata nAsrRes;
  52   1              MCU_init();
  53   1              UART_init();
  54   1              LD_reset();
  55   1              BUZZ=0;
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 2   

  56   1              LED_TEST();                                             //测试LED灯
  57   1              nAsrStatus = LD_ASR_NONE;               //      初始状态：没有在作ASR   
  58   1              PlaySound(8);                                   //      播放提示音：为第九条声音9-Verygood
  59   1              while(1)
  60   1              {
  61   2                      if (bMp3Play!=0)                        //      如果还在播放MP3中，则等待，直到MP3播放完毕 即bMp3Play==0
  62   2                              continue;                               //      bMp3Play 是定义的一个全局变量用来记录MP3播放的状态，不是LD3320芯片内部的寄存器
  63   2      
  64   2                      switch(nAsrStatus)
  65   2                      {
  66   3                              case LD_ASR_RUNING:
  67   3                              case LD_ASR_ERROR:              
  68   3                                      break;
  69   3                              case LD_ASR_NONE:
  70   3                              {
  71   4                                      //FlashLED(1);
  72   4                                      nAsrStatus=LD_ASR_RUNING;
  73   4                                      if (RunASR()==0)        //      启动一次ASR识别流程：ASR初始化，ASR添加关键词语，启动ASR运算
  74   4                                      {
  75   5                                              nAsrStatus = LD_ASR_ERROR;
  76   5                                      }
  77   4                                      break;
  78   4                              }
  79   3                              case LD_ASR_FOUNDOK:
  80   3                              {
  81   4                                      nAsrRes = LD_GetResult();       //      一次ASR识别流程结束，去取ASR识别结果
  82   4                                      OutputIO(nAsrRes);                      //  根据识别结果，在相应的IO管脚上输出1秒钟左右的低电平，开发者可以通过IO管脚输出
             -到其他设备进行声控。
  83   4                                      if(nAsrRes<Same_VOIC_COUNT)     
  84   4                                      {
  85   5                                      PlaySound(nAsrRes);         //  播放识别语音                            
  86   5                                      }
  87   4                                      nAsrStatus = LD_ASR_NONE;                               
  88   4                                      break;
  89   4                              }
  90   3                              case LD_ASR_FOUNDZERO:
  91   3                              default:
  92   3                              {
  93   4                                      //FlashLED(1);
  94   4                                      //PlaySound(0);
  95   4                                      nAsrStatus = LD_ASR_NONE;
  96   4                                      break;
  97   4                              }
  98   3                      }// switch
  99   2              }// while
 100   1      
 101   1      }
 102          
 103          void MCU_init()
 104          {
 105   1              P1M0 |= 1;
 106   1              P3M0 |= 8;
 107   1              P4SW = 0xFF;
 108   1              P0 = 0xff;
 109   1              P1 = 0xff;
 110   1              P2 = 0xff;
 111   1              P3 = 0xf7;
 112   1              P4 = 0x3f;
 113   1      
 114   1      
 115   1      #if defined (SOFT_SPI_PORT)             //      软件模拟SPI读写
                      LD_MODE = 1;                            //      设置MD管脚为高
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 3   

              #elif defined (HARD_SPI_PORT)   //      硬件实现SPI读写
                      LD_MODE = 1;                            //      设置MD管脚为高
              #else                                                   //      并行读写 （硬件实现或者软件模拟）
 120   1              LD_MODE = 0;                            //      设置MD管脚为低
 121   1      #endif
 122   1      
 123   1      
 124   1              IP=0;
 125   1              IPH=0;
 126   1      
 127   1              PX0=1; 
 128   1              PT0=1;
 129   1              PS=1;
 130   1              IPH |= 1;       
 131   1              
 132   1              EX0=0;
 133   1              EX1=0;
 134   1              EA=1;
 135   1      }
 136          
 137          void  delay(unsigned long uldata)
 138          {
 139   1              unsigned int j  =  0;
 140   1              unsigned long g  =  0;
 141   1              for (j=0;j<5;j++)
 142   1              {
 143   2                      for (g=0;g<uldata;g++)
 144   2                      {
 145   3                              _nop_();
 146   3                              _nop_();
 147   3                              _nop_();
 148   3                      }
 149   2              }
 150   1      }
 151          
 152          /*********************************************************************
 153          //为了消除编译时的 警告 *** WARNING L15: MULTIPLE CALL TO SEGMENT
 154          //把在中断函数中需要调用的函数重新复制并命名
 155          //消除警告 Warning L15，并且避免由于函数重入可能带来的隐藏Bug
 156          /*********************************************************************/
 157          
 158          void  delay_2(unsigned long uldata)
 159          {
 160   1              unsigned int j  =  0;
 161   1              unsigned long g  =  0;
 162   1              for (j=0;j<5;j++)
 163   1              {
 164   2                      for (g=0;g<uldata;g++)
 165   2                      {
 166   3                              _nop_();
 167   3                              _nop_();
 168   3                              _nop_();
 169   3                      }
 170   2              }
 171   1      }
 172          
 173          void FlashLED(uint8 nTimes)
 174          {
 175   1              uint8 k;
 176   1              for (k=0; k<nTimes; k++)
 177   1              {
 178   2                      DS01=0;
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 4   

 179   2                      DS02=0;
 180   2                      BUZZ=1;
 181   2                      delay(5000);
 182   2                      DS01=1;
 183   2                      DS02=1;
 184   2                      BUZZ=0;
 185   2                      delay(5000);
 186   2              }
 187   1      }
 188          
 189          
 190          void LED_TEST()
 191          {
 192   1      DS01=0;DS02=1;DS03=1;DS04=1;DS05=1;DS06=1;DS07=1;DS08=1;DS09=1;
 193   1      delay(2500);
 194   1      DS01=0;DS02=0;DS03=1;DS04=1;DS05=1;DS06=1;DS07=1;DS08=1;DS09=1;
 195   1      delay(2500);
 196   1      DS01=0;DS02=0;DS03=0;DS04=1;DS05=1;DS06=1;DS07=1;DS08=1;DS09=1;
 197   1      delay(2500);
 198   1      DS01=0;DS02=0;DS03=0;DS04=0;DS05=1;DS06=1;DS07=1;DS08=1;DS09=1;
 199   1      delay(2500);
 200   1      DS01=0;DS02=0;DS03=0;DS04=0;DS05=0;DS06=1;DS07=1;DS08=1;DS09=1;
 201   1      delay(2500);
 202   1      DS01=0;DS02=0;DS03=0;DS04=0;DS05=0;DS06=0;DS07=1;DS08=1;DS09=1;
 203   1      delay(2500);
 204   1      DS01=0;DS02=0;DS03=0;DS04=0;DS05=0;DS06=0;DS07=0;DS08=1;DS09=1;
 205   1      delay(2500);
 206   1      DS01=0;DS02=0;DS03=0;DS04=0;DS05=0;DS06=0;DS07=0;DS08=0;DS09=1;
 207   1      delay(2500);
 208   1      DS01=0;DS02=0;DS03=0;DS04=0;DS05=0;DS06=0;DS07=0;DS08=0;DS09=0;
 209   1      delay(4000);
 210   1      DS01=1;DS02=1;DS03=1;DS04=1;DS05=1;DS06=1;DS07=1;DS08=1;DS09=1;
 211   1      }
 212          /************************************************************************************/
 213          //
 214          //      IO_Send_Byte()是主控MCU向spi-flash (型号为华邦的 W25Q32)发送指令
 215          //      开发者应该根据自己使用的存储芯片去写具体的函数
 216          //
 217          //      ICroute公司无法对存储芯片的读写提供技术支持，
 218          //      开发者需要自己向自己使用的存储芯片的厂商获得技术支持
 219          //      或者在网络上搜索相关代码和文档
 220          //
 221          //      华邦的spi-flash的技术支持的文档页面在：
 222          //      http://www.winbond.com.tw/hq/cht/ProductAndSales/ProductLines/FlashMemory/SerialFlash/
 223          //      http://www.xtdpj.com/show_hdr.php?xname=915RL41&dname=23T0M41&xpos=84
 224          /************************************************************************************/
 225          
 226          void IO_Send_Byte(uint8 dataout)
 227          {
 228   1               uint8 i = 0; 
 229   1               FLASH_CS = 0;
 230   1               for (i=0; i<8; i++)
 231   1               {
 232   2                        if ((dataout & 0x80) == 0x80) 
 233   2                                 FLASH_DIO = 1;
 234   2                        else
 235   2                                 FLASH_DIO = 0;
 236   2                        FLASH_CLK = 1;
 237   2                        dataout = (dataout << 1); 
 238   2                        FLASH_CLK = 0;   
 239   2               }
 240   1      }
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 5   

 241          
 242          
 243          /************************************************************************************/
 244          //      RunASR()函数实现了一次完整的ASR语音识别流程
 245          //      LD_AsrStart() 函数实现了ASR初始化
 246          //      LD_AsrAddFixed() 函数实现了添加关键词语到LD3320芯片中
 247          //      LD_AsrRun()     函数启动了一次ASR语音识别流程
 248          //
 249          //      任何一次ASR识别流程，都需要按照这个顺序，从初始化开始进行
 250          /************************************************************************************/
 251          
 252          uint8 RunASR()
 253          {
 254   1              uint8 i=0;
 255   1              uint8 asrflag=0;
 256   1              for (i=0; i<5; i++)                     //      防止由于硬件原因导致LD3320芯片工作不正常，所以一共尝试5次启动ASR识别流程
 257   1              {
 258   2                      LD_AsrStart();
 259   2                      delay(100);
 260   2                      if (LD_AsrAddFixed()==0)
 261   2                      {
 262   3                              LD_reset();                     //      LD3320芯片内部出现不正常，立即重启LD3320芯片
 263   3                              delay(100);                     //      并从初始化开始重新ASR识别流程
 264   3                              continue;
 265   3                      }
 266   2                      delay(10);
 267   2                      if (LD_AsrRun() == 0)
 268   2                      {
 269   3                              LD_reset();                     //      LD3320芯片内部出现不正常，立即重启LD3320芯片
 270   3                              delay(100);                     //      并从初始化开始重新ASR识别流程
 271   3                              continue;
 272   3                      }
 273   2      
 274   2                      asrflag=1;
 275   2                      break;                                  //      ASR流程启动成功，退出当前for循环。开始等待LD3320送出的中断信号
 276   2              }
 277   1      
 278   1              return asrflag;
 279   1      }
 280          
 281          void ExtInt0Handler(void) interrupt 0  
 282          {
 283   1              ProcessInt0();                          //      LD3320 送出中断信号，包括ASR和播放MP3的中断，需要在中断处理函数中分别处理
 284   1      }
 285          
 286          //-------------------------------------------------------
 287          void UART_init()                        //进行串口的相关信息初始化工作
 288          {
 289   1      #define   RELOAD_COUNT   0XFA
 290   1      
 291   1              SCON  =  0x50;             //0101，0000  8位可变波特率，无奇偶校验位
 292   1              BRT   =  RELOAD_COUNT;     ////定义波特率发生器重载值，晶体频率22.1184M,1T,SMOD=0;波特率115200bps    
 293   1              AUXR  =  0x15;  //将BRTR=1，BRTx12=1(1T模式)，SBRS=1
 294   1                            //T0x12,T1x12,UART_M0x6,BRTR,S2SMOD,BRTx12,XRAM,SBRS
 295   1                            //Baud=Fosc/(256-RELOAD_COUNT)/32/12  (12T模式)
 296   1                            //Baud=Fosc/(256-RELOAD_COUNT)/32     (1T模式)
 297   1                            //BRTR=1，启动独立波特率发生器
 298   1                            //S1BRS=1，串口1选择独立波特率发生器作为波特率发生器
 299   1                            //此时定时器1可以释放出来作为定时器，计数器，时钟输出使用
 300   1              //AUXR1=0x80；//释放该行指令，则串行口从P3切换到P1，设计串口在P1,不支持
 301   1      
 302   1      
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 6   

 303   1              TMOD = 0x21;    // 0010 0001 
 304   1                                              //设置定时器0为16位计数器
 305   1                                              //设置定时器1为8位自动重载计数器
 306   1      
 307   1              TR0 = 0;
 308   1              TR1 = 0;        // 前面设置了专用波特率发生器。不使用Timer1.
 309   1      
 310   1              ES    =   1;      //允许串口中断
 311   1              EA    =   1;      //开总中断    
 312   1                                                  
 313   1      }
 314          
 315          //以下几个函数为从串口打印信息到PC机的函数，开发者可以直接调用
 316          void SendChar (uint8 data_to_tx) 
 317          {
 318   1      #ifdef LD_DEBUG
 319   1              ES        =             0;  //关串口中断
 320   1              TI    =   0;  //清零串口发送完成中断请求标志
 321   1              SBUF  =  data_to_tx;
 322   1              while(TI==0); //等待发送完成
 323   1              TI    =   0;
 324   1              ES    =   1;  //允许串口中断
 325   1      #endif
 326   1      }
 327          
 328          void SendLineEnd(void) 
 329          {
 330   1      #ifdef LD_DEBUG
 331   1              SendChar(0x0D);
 332   1              SendChar(0x0A);
 333   1      #endif
 334   1      }
 335          
 336          void SendString(unsigned char *pt)
 337          {
 338   1      #ifdef LD_DEBUG
 339   1          while(*pt)
 340   1                      SendChar(*(pt++));
 341   1      #endif
 342   1      }
 343          
 344          void SendByteHex (uint8 value)
 345          {
 346   1      #ifdef LD_DEBUG
 347   1              uint8 idata ch1 = value & 0xF0;
 348   1              ch1 = ch1>>4;
 349   1              if (ch1>9)
 350   1                      ch1 = 'A' + ch1 - 10;
 351   1              else 
 352   1                      ch1 = '0' + ch1;
 353   1              SendChar(ch1);
 354   1              ch1 = value & 0x0F;
 355   1              if (ch1>9)
 356   1                      ch1 = 'A' + ch1 - 10;
 357   1              else 
 358   1                      ch1 = '0' + ch1;
 359   1              SendChar(ch1);
 360   1              SendChar(' ');
 361   1      #endif
 362   1      }
 363          
 364          void SendLongHex (uint32 value)
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 7   

 365          {
 366   1      #ifdef LD_DEBUG
 367   1              uint8 idata bt;
 368   1              SendChar('[');
 369   1              bt = (uint8)(value>>24);
 370   1              SendByteHex(bt);
 371   1              bt = (uint8)((value&0x00FF0000L)>>16);
 372   1              SendByteHex(bt);
 373   1              bt = (uint8)((value&0x0000FF00L)>>8);
 374   1              SendByteHex(bt);
 375   1              bt = (uint8)((value&0x000000FFL));
 376   1              SendByteHex(bt);
 377   1              SendChar(']');
 378   1              SendChar(' ');
 379   1      #endif
 380   1      }
 381          
 382          
 383          //在某个IO管脚上输出高低电平控制LDE灯亮灭
 384          //如果开发者不需要这一步骤，可以去除，从而减少识别结束到播放声音的延时
 385          void OutputIO(uint8 nRes)
 386          {
 387   1              switch(nRes)
 388   1              {
 389   2              case 0:
 390   2              FlashLED(1);DS03=0;break;
 391   2              //KEY0=0; delay(60000); KEY0=1; break;
 392   2              case 1:
 393   2              FlashLED(1);DS03=1;break;
 394   2              //LED0=0; delay(60000); LED0=1; break;
 395   2              case 2:
 396   2              FlashLED(1);DS04=0;break;
 397   2              //KEY3=0; delay(60000); KEY3=1; break;
 398   2              case 3:
 399   2              FlashLED(1);DS04=1;break;       
 400   2              //LED1=0; delay(60000); LED1=1; break;
 401   2              case 4:
 402   2              FlashLED(1);DS05=0;break;
 403   2              //TP1=0; delay(60000); TP1=1; break;
 404   2              case 5:
 405   2              FlashLED(1);DS05=1;break;
 406   2              //P45=0; delay(60000); P45=1; break;
 407   2              case 6:
 408   2              FlashLED(1);DS06=0;break;
 409   2              //KEY1=0; delay(60000); KEY1=1; break;
 410   2              case 7:
 411   2              FlashLED(1);DS06=1;break;
 412   2              case 8:
 413   2              FlashLED(1);DS07=0;break;
 414   2              case 9:
 415   2              FlashLED(1);DS07=1;Send_getbacknum(9);break;
 416   2              case 10:
 417   2              FlashLED(1);DS08=0;Send_getbacknum(10);break;
 418   2              case 11:
 419   2              FlashLED(1);DS08=1;Send_getbacknum(11);break;
 420   2              case 12:
 421   2              FlashLED(1);DS09=0;Send_getbacknum(12);break;
 422   2              case 13:
 423   2          FlashLED(1);DS09=1;Send_getbacknum(13);break;
 424   2              //*******更多操作请自行添加*********//
 425   2              }
 426   1      }
C51 COMPILER V7.10   MAIN                                                                  09/12/2011 22:11:31 PAGE 8   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1096    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      27
   IDATA SIZE       =      1       3
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
