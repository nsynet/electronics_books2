C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE LDCHIP
OBJECT MODULE PLACED IN LDChip.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LDChip.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************************************/
   2          //      版权所有：Copyright (c) 2005 - 2010 ICRoute INC.
   3          /************************************************************************************/
   4          #include "STC10F08XE.H"
   5          #include "LDChip.h"
   6          #include "Reg_RW.h"
   7          #include "FlashDef.h"
   8          #include "AsrItem.h"
   9          #include "SubFuncs.h"
  10          
  11          sbit RSTB=P3^3;
  12          sbit CSB=P2^6;
  13          
  14          uint32 nMp3StartPos=0;
  15          uint32 nMp3Size=0;
  16          uint32 nMp3Pos=0;
  17          uint32 nCurMp3Pos=0;
  18          uint8  idata nLD_Mode = LD_MODE_IDLE;           //      用来记录当前是在进行ASR识别还是在播放MP3
  19          uint8 bMp3Play=0;                                                       //      用来记录播放MP3的状态
  20          uint8 idata ucRegVal;
  21          uint8 idata ucHighInt;
  22          uint8 idata ucLowInt;
  23          uint8 idata ucStatus;
  24          uint8 idata ucSPVol=15; // MAX=15 MIN=0         //      Speaker喇叭输出的音量
  25          
  26          extern uint8 idata nAsrStatus;
  27          void ProcessInt0();
  28          
  29          /************************************************************************************/
  30          //      这个C文件里面包含的函数，相当于LD3320的驱动，以C语言源代码的形式提供
  31          //      开发者在没有调试通过之前，一定不要修改这里面的函数
  32          //      
  33          //      LD_ReloadMp3Data()函数由于牵涉到主控MCU向外部存储芯片读取MP3数据的操作
  34          //      所以开发者应该根据自己的实际使用的存储芯片，去修改这个函数
  35          //      但是要保证对于LD3320芯片的操作不改变
  36          //
  37          //      LD_GetResult()函数目前只简单取了第一候选结果作为识别结果
  38          //      开发者应该根据自己产品设计，决定是否要读取其他的识别候选结果
  39          /************************************************************************************/
  40          
  41          
  42          
  43          void LD_reset()
  44          {
  45   1              RSTB=1;
  46   1              delay(1);
  47   1              RSTB=0;
  48   1              delay(1);
  49   1              RSTB=1;
  50   1      
  51   1              delay(1);
  52   1              CSB=0;
  53   1              delay(1);
  54   1              CSB=1;
  55   1              delay(1);
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 2   

  56   1      }
  57          
  58          void LD_Init_Common()
  59          {
  60   1              bMp3Play = 0;
  61   1      
  62   1              LD_ReadReg(0x06);  
  63   1              LD_WriteReg(0x17, 0x35); 
  64   1              delay(10);
  65   1              LD_ReadReg(0x06);  
  66   1      
  67   1              LD_WriteReg(0x89, 0x03);  
  68   1              delay(5);
  69   1              LD_WriteReg(0xCF, 0x43);   
  70   1              delay(5);
  71   1              LD_WriteReg(0xCB, 0x02);
  72   1              
  73   1              /*PLL setting*/
  74   1              LD_WriteReg(0x11, LD_PLL_11);       
  75   1              if (nLD_Mode == LD_MODE_MP3)
  76   1              {
  77   2                      LD_WriteReg(0x1E, 0x00); 
  78   2                      LD_WriteReg(0x19, LD_PLL_MP3_19);   
  79   2                      LD_WriteReg(0x1B, LD_PLL_MP3_1B);   
  80   2                      LD_WriteReg(0x1D, LD_PLL_MP3_1D);
  81   2              }
  82   1              else
  83   1              {
  84   2                      LD_WriteReg(0x1E,0x00);
  85   2                      LD_WriteReg(0x19, LD_PLL_ASR_19); 
  86   2                      LD_WriteReg(0x1B, LD_PLL_ASR_1B);               
  87   2                  LD_WriteReg(0x1D, LD_PLL_ASR_1D);
  88   2              }
  89   1              delay(10);
  90   1              
  91   1              LD_WriteReg(0xCD, 0x04);
  92   1              LD_WriteReg(0x17, 0x4C); 
  93   1              delay(5);
  94   1              LD_WriteReg(0xB9, 0x00);
  95   1              LD_WriteReg(0xCF, 0x4F); 
  96   1              LD_WriteReg(0x6F, 0xFF); 
  97   1      }
  98          
  99          void LD_Init_MP3()
 100          {
 101   1              nLD_Mode = LD_MODE_MP3;
 102   1              LD_Init_Common();
 103   1      
 104   1              LD_WriteReg(0xBD,0x02);
 105   1              LD_WriteReg(0x17, 0x48);
 106   1              delay(10);
 107   1      
 108   1              LD_WriteReg(0x85, 0x52); 
 109   1              LD_WriteReg(0x8F, 0x00);  
 110   1              LD_WriteReg(0x81, 0x00);
 111   1              LD_WriteReg(0x83, 0x00);
 112   1              LD_WriteReg(0x8E, 0xff);
 113   1              LD_WriteReg(0x8D, 0xff);
 114   1          delay(1);
 115   1              LD_WriteReg(0x87, 0xff);
 116   1              LD_WriteReg(0x89, 0xff);
 117   1              delay(1);
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 3   

 118   1              LD_WriteReg(0x22, 0x00);    
 119   1              LD_WriteReg(0x23, 0x00);
 120   1              LD_WriteReg(0x20, 0xef);    
 121   1              LD_WriteReg(0x21, 0x07);
 122   1              LD_WriteReg(0x24, 0x77);          
 123   1          LD_WriteReg(0x25, 0x03);
 124   1          LD_WriteReg(0x26, 0xbb);    
 125   1          LD_WriteReg(0x27, 0x01); 
 126   1      }
 127                  
 128          void LD_Init_ASR()
 129          {
 130   1              nLD_Mode=LD_MODE_ASR_RUN;
 131   1              LD_Init_Common();
 132   1      
 133   1              LD_WriteReg(0xBD, 0x00);
 134   1              LD_WriteReg(0x17, 0x48);
 135   1              delay( 10 );
 136   1      
 137   1              LD_WriteReg(0x3C, 0x80);    
 138   1              LD_WriteReg(0x3E, 0x07);
 139   1              LD_WriteReg(0x38, 0xff);    
 140   1              LD_WriteReg(0x3A, 0x07);
 141   1              
 142   1              LD_WriteReg(0x40, 0);          
 143   1              LD_WriteReg(0x42, 8);
 144   1              LD_WriteReg(0x44, 0);    
 145   1              LD_WriteReg(0x46, 8); 
 146   1              delay( 1 );
 147   1      }
 148          
 149          
 150          void ProcessInt0()
 151          {
 152   1              uint8 nAsrResCount=0;
 153   1      
 154   1              EX0=0;
 155   1              
 156   1              ucRegVal = LD_ReadReg(0x2B);
 157   1              if(nLD_Mode == LD_MODE_ASR_RUN)
 158   1              {
 159   2                      // 语音识别产生的中断
 160   2                      // （有声音输入，不论识别成功或失败都有中断）
 161   2                      LD_WriteReg(0x29,0) ;
 162   2                      LD_WriteReg(0x02,0) ;
 163   2                      if((ucRegVal & 0x10) &&
 164   2                              LD_ReadReg(0xb2)==0x21 && 
 165   2                              LD_ReadReg(0xbf)==0x35)
 166   2                      {
 167   3                              nAsrResCount = LD_ReadReg(0xba);
 168   3                              if(nAsrResCount>0 && nAsrResCount<=4) 
 169   3                              {
 170   4                                      nAsrStatus=LD_ASR_FOUNDOK;
 171   4                              }
 172   3                              else
 173   3                          {
 174   4                                      nAsrStatus=LD_ASR_FOUNDZERO;
 175   4                              }       
 176   3                      }
 177   2                      else
 178   2                      {
 179   3                              nAsrStatus=LD_ASR_FOUNDZERO;
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 4   

 180   3                      }
 181   2                              
 182   2                      LD_WriteReg(0x2b, 0);
 183   2              LD_WriteReg(0x1C,0);
 184   2                      return;
 185   2              }
 186   1              
 187   1              // 声音播放产生的中断，有三种：
 188   1              // A. 声音数据已全部播放完。
 189   1              // B. 声音数据已发送完毕。
 190   1              // C. 声音数据暂时将要用完，需要放入新的数据。  
 191   1              ucHighInt = LD_ReadReg(0x29); 
 192   1              ucLowInt=LD_ReadReg(0x02); 
 193   1              LD_WriteReg(0x29,0) ;
 194   1              LD_WriteReg(0x02,0) ;
 195   1          if(LD_ReadReg(0xBA)&CAUSE_MP3_SONG_END)
 196   1          {
 197   2              // A. 声音数据已全部播放完。
 198   2      
 199   2                      LD_WriteReg(0x2B,  0);
 200   2              LD_WriteReg(0xBA, 0);   
 201   2                      LD_WriteReg(0xBC,0x0);  
 202   2                      bMp3Play=0;                                     // 声音数据全部播放完后，修改bMp3Play的变量
 203   2                      LD_WriteReg(0x08,1);
 204   2                      delay_2(5);
 205   2              LD_WriteReg(0x08,0);
 206   2                      LD_WriteReg(0x33, 0);
 207   2      
 208   2                      return ;
 209   2           }
 210   1      
 211   1               if(nMp3Pos>=nMp3Size)
 212   1              {
 213   2              // B. 声音数据已发送完毕。
 214   2      
 215   2                      LD_WriteReg(0xBC, 0x01);
 216   2                      LD_WriteReg(0x29, 0x10);
 217   2      //              bMp3Play=0;                             //      此时，只是主控MCU把所有MP3数据发送到LD3320芯片内，但是还没有把送入的数据全部播放完毕
 218   2                      EX0=1;
 219   2      
 220   2                      return; 
 221   2              }
 222   1      
 223   1              // C. 声音数据暂时将要用完，需要放入新的数据。  
 224   1      
 225   1              LD_ReloadMp3Data_2();
 226   1                      
 227   1              LD_WriteReg(0x29,ucHighInt); 
 228   1              LD_WriteReg(0x02,ucLowInt) ;
 229   1      
 230   1              delay_2(10);
 231   1              EX0=1;
 232   1      
 233   1      }
 234          
 235          
 236          
 237          
 238          void LD_play()
 239          {
 240   1              nMp3Pos=0;
 241   1              bMp3Play=1;
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 5   

 242   1      
 243   1              if (nMp3Pos >=  nMp3Size)
 244   1                      return ; 
 245   1      
 246   1              LD_ReloadMp3Data();
 247   1      
 248   1          LD_WriteReg(0xBA, 0x00);
 249   1              LD_WriteReg(0x17, 0x48);
 250   1              LD_WriteReg(0x33, 0x01);
 251   1              LD_WriteReg(0x29, 0x04);
 252   1              
 253   1              LD_WriteReg(0x02, 0x01); 
 254   1              LD_WriteReg(0x85, 0x5A);
 255   1      
 256   1              EX0=1;
 257   1      
 258   1      }
 259          
 260          void LD_AdjustMIX2SPVolume(uint8 val)
 261          {
 262   1              ucSPVol = val;
 263   1              val = ((15-val)&0x0f) << 2;
 264   1              LD_WriteReg(0x8E, val | 0xc3); 
 265   1              LD_WriteReg(0x87, 0x78); 
 266   1      }
 267          
 268          void LD_ReloadMp3Data()
 269          {
 270   1              uint32 nCurMp3Pos;
 271   1              uint8 val;
 272   1              uint8 k;
 273   1      
 274   1              nCurMp3Pos = nMp3StartPos + nMp3Pos;
 275   1              FLASH_CS=1;
 276   1              FLASH_CLK=0;
 277   1              FLASH_CS=0;
 278   1      
 279   1               IO_Send_Byte(W25P_FastReadData);   
 280   1               IO_Send_Byte(((nCurMp3Pos & 0xFFFFFF) >> 16));  
 281   1               IO_Send_Byte(((nCurMp3Pos & 0xFFFF) >> 8));
 282   1               IO_Send_Byte(nCurMp3Pos & 0xFF);
 283   1               IO_Send_Byte(0xFF);
 284   1      
 285   1              ucStatus = LD_ReadReg(0x06);
 286   1              while ( !(ucStatus&MASK_FIFO_STATUS_AFULL) && (nMp3Pos<nMp3Size) )
 287   1              {
 288   2                      val=0;
 289   2                      for(k=0;k<8;k++)
 290   2                      {
 291   3                              FLASH_CLK=0;
 292   3                              val<<=1;
 293   3                              FLASH_CLK=1;
 294   3                              val|=FLASH_DO;
 295   3                      }
 296   2                      LD_WriteReg(0x01,val);
 297   2      
 298   2                      nMp3Pos++;
 299   2      
 300   2                      ucStatus = LD_ReadReg(0x06);
 301   2              }
 302   1              
 303   1              FLASH_CS=1;
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 6   

 304   1              FLASH_CLK=0;
 305   1      
 306   1      }
 307          /*********************************************************************
 308          //为了消除编译时的 警告 *** WARNING L15: MULTIPLE CALL TO SEGMENT
 309          //把在中断函数中需要调用的函数重新复制并命名
 310          //消除警告 Warning L15，并且避免由于函数重入可能带来的隐藏Bug
 311          /*********************************************************************/
 312          
 313          void LD_ReloadMp3Data_2()
 314          {
 315   1              uint32 nCurMp3Pos;
 316   1              uint8 val;
 317   1              uint8 k;
 318   1      
 319   1              nCurMp3Pos = nMp3StartPos + nMp3Pos;
 320   1              FLASH_CS=1;
 321   1              FLASH_CLK=0;
 322   1              FLASH_CS=0;
 323   1      
 324   1               IO_Send_Byte(W25P_FastReadData);   
 325   1               IO_Send_Byte(((nCurMp3Pos & 0xFFFFFF) >> 16));  
 326   1               IO_Send_Byte(((nCurMp3Pos & 0xFFFF) >> 8));
 327   1               IO_Send_Byte(nCurMp3Pos & 0xFF);
 328   1               IO_Send_Byte(0xFF);
 329   1      
 330   1              ucStatus = LD_ReadReg(0x06);
 331   1              while ( !(ucStatus&MASK_FIFO_STATUS_AFULL) && (nMp3Pos<nMp3Size) )
 332   1              {
 333   2                      val=0;
 334   2                      for(k=0;k<8;k++)
 335   2                      {
 336   3                              FLASH_CLK=0;
 337   3                              val<<=1;
 338   3                              FLASH_CLK=1;
 339   3                              val|=FLASH_DO;
 340   3                      }
 341   2                      LD_WriteReg(0x01,val);
 342   2      
 343   2                      nMp3Pos++;
 344   2      
 345   2                      ucStatus = LD_ReadReg(0x06);
 346   2              }
 347   1              
 348   1              FLASH_CS=1;
 349   1              FLASH_CLK=0;
 350   1      
 351   1      }
 352          
 353          // Return 1: success.
 354          uint8 LD_Check_ASRBusyFlag_b2()
 355          {
 356   1              uint8 j;
 357   1              uint8 flag = 0;
 358   1              for (j=0; j<10; j++)
 359   1              {
 360   2                      if (LD_ReadReg(0xb2) == 0x21)
 361   2                      {
 362   3                              flag = 1;
 363   3                              break;
 364   3                      }
 365   2                      delay(10);              
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 7   

 366   2              }
 367   1              return flag;
 368   1      }
 369          
 370          void LD_AsrStart()
 371          {
 372   1              LD_Init_ASR();
 373   1      }
 374          
 375          // Return 1: success.
 376          uint8 LD_AsrRun()
 377          {
 378   1              SendString("LD_AsrRun().");
 379   1              SendLineEnd();
 380   1      
 381   1              LD_WriteReg(0x35, MIC_VOL);
 382   1      //      LD_WriteReg(0xB3, 0x0D);        // 用户阅读 开发手册 理解B3寄存器的调整对于灵敏度和识别距离的影响
 383   1      
 384   1      
 385   1              LD_WriteReg(0x1C, 0x09);
 386   1              LD_WriteReg(0xBD, 0x20);
 387   1              LD_WriteReg(0x08, 0x01);
 388   1              delay( 1 );
 389   1              LD_WriteReg(0x08, 0x00);
 390   1              delay( 1 );
 391   1      
 392   1              if(LD_Check_ASRBusyFlag_b2() == 0)
 393   1              {
 394   2                      return 0;
 395   2              }
 396   1      
 397   1              LD_WriteReg(0xB2, 0xff);        
 398   1              LD_WriteReg(0x37, 0x06);
 399   1              delay( 5 );
 400   1              LD_WriteReg(0x1C, 0x0b);
 401   1              LD_WriteReg(0x29, 0x10);
 402   1              
 403   1              LD_WriteReg(0xBD, 0x00);
 404   1              EX0=1;
 405   1              return 1;
 406   1      }
 407          
 408          void LD_AsrAddFixed_ByString(char * pRecogString, uint8 k)
 409          {
 410   1              uint8 nAsrAddLength;
 411   1      
 412   1              SendByteHex(k);
 413   1              SendString("    ");
 414   1              SendString(pRecogString);
 415   1              SendLineEnd();
 416   1      
 417   1              if (*pRecogString==0)
 418   1                      return;
 419   1      
 420   1              LD_WriteReg(0xc1, k );
 421   1              LD_WriteReg(0xc3, 0 );
 422   1              LD_WriteReg(0x08, 0x04);
 423   1              delay(1);
 424   1              LD_WriteReg(0x08, 0x00);
 425   1              delay(1);
 426   1      
 427   1      
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 8   

 428   1      
 429   1      
 430   1              for (nAsrAddLength=0; nAsrAddLength<50; nAsrAddLength++)
 431   1              {
 432   2                      if (pRecogString[nAsrAddLength] == 0)
 433   2                              break;
 434   2                      LD_WriteReg(0x5, pRecogString[nAsrAddLength]);
 435   2              }
 436   1              
 437   1              LD_WriteReg(0xb9, nAsrAddLength);
 438   1              LD_WriteReg(0xb2, 0xff);
 439   1              LD_WriteReg(0x37, 0x04);
 440   1      }
 441          
 442          void LD_AsrAddFixed_ByIndex(uint8 nIndex)
 443          {
 444   1              switch(nIndex)
 445   1              {
 446   2              case  0: LD_AsrAddFixed_ByString(STR_00,nIndex); break;
 447   2              case  1: LD_AsrAddFixed_ByString(STR_01,nIndex); break;
 448   2              case  2: LD_AsrAddFixed_ByString(STR_02,nIndex); break;
 449   2              case  3: LD_AsrAddFixed_ByString(STR_03,nIndex); break;
 450   2              case  4: LD_AsrAddFixed_ByString(STR_04,nIndex); break;
 451   2              case  5: LD_AsrAddFixed_ByString(STR_05,nIndex); break;
 452   2              case  6: LD_AsrAddFixed_ByString(STR_06,nIndex); break;
 453   2              case  7: LD_AsrAddFixed_ByString(STR_07,nIndex); break;
 454   2              case  8: LD_AsrAddFixed_ByString(STR_08,nIndex); break;
 455   2              case  9: LD_AsrAddFixed_ByString(STR_09,nIndex); break;
 456   2              case 10: LD_AsrAddFixed_ByString(STR_10,nIndex); break;
 457   2              case 11: LD_AsrAddFixed_ByString(STR_11,nIndex); break;
 458   2              case 12: LD_AsrAddFixed_ByString(STR_12,nIndex); break;
 459   2              case 13: LD_AsrAddFixed_ByString(STR_13,nIndex); break;
 460   2              case 14: LD_AsrAddFixed_ByString(STR_14,nIndex); break;
 461   2              case 15: LD_AsrAddFixed_ByString(STR_15,nIndex); break;
 462   2              case 16: LD_AsrAddFixed_ByString(STR_16,nIndex); break;
 463   2              case 17: LD_AsrAddFixed_ByString(STR_17,nIndex); break;
 464   2              case 18: LD_AsrAddFixed_ByString(STR_18,nIndex); break;
 465   2              case 19: LD_AsrAddFixed_ByString(STR_19,nIndex); break;
 466   2              case 20: LD_AsrAddFixed_ByString(STR_20,nIndex); break;
 467   2              case 21: LD_AsrAddFixed_ByString(STR_21,nIndex); break;
 468   2              case 22: LD_AsrAddFixed_ByString(STR_22,nIndex); break;
 469   2              case 23: LD_AsrAddFixed_ByString(STR_23,nIndex); break;
 470   2              case 24: LD_AsrAddFixed_ByString(STR_24,nIndex); break;
 471   2              case 25: LD_AsrAddFixed_ByString(STR_25,nIndex); break;
 472   2              case 26: LD_AsrAddFixed_ByString(STR_26,nIndex); break;
 473   2              case 27: LD_AsrAddFixed_ByString(STR_27,nIndex); break;
 474   2              case 28: LD_AsrAddFixed_ByString(STR_28,nIndex); break;
 475   2              case 29: LD_AsrAddFixed_ByString(STR_29,nIndex); break;
 476   2              case 30: LD_AsrAddFixed_ByString(STR_30,nIndex); break;
 477   2              case 31: LD_AsrAddFixed_ByString(STR_31,nIndex); break;
 478   2              case 32: LD_AsrAddFixed_ByString(STR_32,nIndex); break;
 479   2              case 33: LD_AsrAddFixed_ByString(STR_33,nIndex); break;
 480   2              case 34: LD_AsrAddFixed_ByString(STR_34,nIndex); break;
 481   2              case 35: LD_AsrAddFixed_ByString(STR_35,nIndex); break;
 482   2              case 36: LD_AsrAddFixed_ByString(STR_36,nIndex); break;
 483   2              case 37: LD_AsrAddFixed_ByString(STR_37,nIndex); break;
 484   2              case 38: LD_AsrAddFixed_ByString(STR_38,nIndex); break;
 485   2              case 39: LD_AsrAddFixed_ByString(STR_39,nIndex); break;
 486   2              case 40: LD_AsrAddFixed_ByString(STR_40,nIndex); break;
 487   2              case 41: LD_AsrAddFixed_ByString(STR_41,nIndex); break;
 488   2              case 42: LD_AsrAddFixed_ByString(STR_42,nIndex); break;
 489   2              case 43: LD_AsrAddFixed_ByString(STR_43,nIndex); break;
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 9   

 490   2              case 44: LD_AsrAddFixed_ByString(STR_44,nIndex); break;
 491   2              case 45: LD_AsrAddFixed_ByString(STR_45,nIndex); break;
 492   2              case 46: LD_AsrAddFixed_ByString(STR_46,nIndex); break;
 493   2              case 47: LD_AsrAddFixed_ByString(STR_47,nIndex); break;
 494   2              case 48: LD_AsrAddFixed_ByString(STR_48,nIndex); break;
 495   2              case 49: LD_AsrAddFixed_ByString(STR_49,nIndex); break;
 496   2      
 497   2              }
 498   1      
 499   1      }
 500          
 501          
 502          // Return 1: success.
 503          //      添加识别关键词语，开发者可以学习"语音识别芯片LD3320高阶秘籍.pdf"中关于垃圾词语吸收错误的用法
 504          uint8 LD_AsrAddFixed()
 505          {
 506   1              uint8 k, flag;
 507   1                      
 508   1              SendString("\nLD_AsrAddFixed().");
 509   1              SendLineEnd();
 510   1      
 511   1      
 512   1              flag = 1;
 513   1              for (k=0; k<ITEM_COUNT; k++)
 514   1              {
 515   2                              
 516   2                      if(LD_Check_ASRBusyFlag_b2() == 0)
 517   2                      {
 518   3                              flag = 0;
 519   3                              break;
 520   3                      }
 521   2                      
 522   2                      LD_AsrAddFixed_ByIndex(k);
 523   2              }
 524   1          return flag;
 525   1      }
 526          
 527          
 528          
 529          uint8 LD_GetResult()
 530          {
 531   1              uint8 res;
 532   1      
 533   1              res = LD_ReadReg(0xc5);
 534   1              SendString("ASR Result = ");
 535   1              SendByteHex(res);
 536   1              SendLineEnd();
 537   1      
 538   1              return res;
 539   1      }
 540          
 541          
 542          void PlaySound(uint8 nCode)
 543          {
 544   1              if (nCode>=ITEM_COUNT)
 545   1                      return;
 546   1      
 547   1      
 548   1              nMp3StartPos = pAsrItem[nCode].nSoundStart;
 549   1              nMp3Size = pAsrItem[nCode].nSoundSize;
 550   1      
 551   1              SendString("PlaySound - ");
C51 COMPILER V7.10   LDCHIP                                                                09/12/2011 22:11:29 PAGE 10  

 552   1              SendByteHex(nCode);
 553   1              SendLongHex(nMp3StartPos);
 554   1              SendLongHex(nMp3Size);
 555   1              SendLineEnd();
 556   1      
 557   1              LD_Init_MP3();
 558   1              LD_AdjustMIX2SPVolume(SPEAKER_VOL);
 559   1              LD_play();
 560   1      }
 561          
 562          void Send_getbacknum(unsigned char Rnum)
 563          {
 564   1      SendString("ASR Result =");
 565   1      SendByteHex(Rnum);
 566   1      switch (Rnum)
 567   1      {
 568   2      case  9: SendString(STR_09);SendLineEnd(); break;
 569   2      case  10: SendString(STR_10);SendLineEnd(); break;
 570   2      case  11: SendString(STR_11);SendLineEnd(); break;
 571   2      case  12: SendString(STR_12);SendLineEnd(); break;
 572   2      case  13: SendString(STR_13);SendLineEnd(); break;
 573   2      }
 574   1      
 575   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2168    ----
   CONSTANT SIZE    =    234    ----
   XDATA SIZE       =     72    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17      24
   IDATA SIZE       =      6    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
