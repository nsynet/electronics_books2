C51 COMPILER V8.18   UART                                                                  08/13/2011 17:58:07 PAGE 1   


C51 COMPILER V8.18, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE uart.c OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /************************************************************
   2           * Uart Program
   3           *   gz.
   4           * 2009.9.28 [complete]   在串口调试和eg-s20d v2.0调试通过
   5           * --------------------------------------------------
   6           * 在PC上通过超级终端或者其它串口调试工具，将键盘按下的值显示
   7           * 在终端上，并将输入的字符串再次输出到终端上。
   8           *
   9           * P30: RXD
  10           * P31: TXD
  11           * W77E58系列的波特率
  12           * 备注：T2发生器：Fosc/(32*(65536-(RCAP2H,RCAP2L))) 
  13           *       T1发生器：TH1=TL1= 256-(F*1000000*(SMOD+1))/(32*12*B) 
  14           ***********************************************************/
  15          #include "STC10F08XE.H"
  16          #include "config.h"
  17          #include "uart.h"
  18          #ifdef debug
  19          
  20          #define RELOAD_COUNT  256-Fclk/(BitRate*12*16)   //22.1184MHz,12T,SMOD=1,9600bps
  21          
  22          //#define use_T2          // 使用定时器2作为波特率发生器
  23          //unsigned char idata g_ucCmd[CMD_LEN + 1] = {0};
  24          //volatile unsigned char  g_ucCmd[CMD_LEN + 1] ;
  25          unsigned char idata g_ucLen = 0;   // 命令长度
  26          unsigned char idata g_ucCur = 1;   // 光标位置
  27          
  28          /************************************************************
  29           * Name: UartInit
  30           * Func:
  31           *  串行通信初始化
  32           * Para: 
  33           *  unsigned char ch: 发送的字符
  34           * Return: None
  35           ***********************************************************/
  36          void UartInit()
  37          {
  38   1              SCON  = 0x50;       // SCON: serail mode 1, 8-bit数据1位起始1位停止 UART
  39   1          TMOD |= 0x20;       // TMOD: timer 1, mode 2, 8-bit reload 
  40   1          PCON |= 0x80;       // SMOD=1;      //波特率加倍
  41   1              BRT     = RELOAD_COUNT;
  42   1              //  BRTR = 1, S1BRS = 1, EXTRAM = 1 ENABLE EXTRAM
  43   1              //普通8051兼容，即12T，独立波特率发生器，允许运行
  44   1              AUXR |= 0x11; // T0x12,T1x12,UART_M0x6,BRTR,S2SMOD,BRTx12,EXTRAM,S1BRS  
  45   1       //  TH1=256-Fclk/(BitRate*12*16); // Baud:9600  fosc=11.0592MHz
  46   1       //   TL1=256-Fclk/(BitRate*12*16); // Baud:9600  fosc=11.0592MHz
  47   1       // IE   |= 0x90;       // 使能串行中断
  48   1       // IP    = 0X10;               // 切记没有用到的中断要禁止不要开，否则程序跑飞
  49   1          TR1   = 1;          // 启动TIMER1
  50   1              ET1=0;              // 禁止定时器1中断
  51   1              EA = 1;
  52   1      }
  53          
  54          /************************************************************
  55           * Name: UartSendStr
C51 COMPILER V8.18   UART                                                                  08/13/2011 17:58:07 PAGE 2   

  56           * Func:
  57           *  向串口发送以0结尾的字符串
  58           * Para: 
  59           *  unsigned char *pStr: 发送的字符指针
  60           * Return: None
  61           ***********************************************************/
  62          void UartSendStr(unsigned char *pStr)
  63          {
  64   1              while(*pStr != 0) 
  65   1              {
  66   2                      SBUF = *pStr++;
  67   2              while(TI==0);
  68   2              TI=0;
  69   2              }
  70   1      }
  71          #if 0
              /************************************************************
               * Name: UartSendChar
               * Func:
               *  向串口发送一个字符
               * Para: 
               *  unsigned char ch: 发送的字符
               * Return: None
               ***********************************************************/
              void UartSendChar(unsigned char ch)
              {
                  SBUF = ch;
                  while(TI==0);
                  TI=0;
              }
              
              code unsigned char HexTable[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
              /********************************************************************/
              void UartSendHex(unsigned char x)
              {
               UartSendChar( '0' );
               UartSendChar( 'X' );
               UartSendChar(HexTable[x>>4]);
               UartSendChar(HexTable[x&0xf]);
               UartSendChar(' ');
              }
              void UartSrv() interrupt 4
              {
                      unsigned char ch;
                      ch = SBUF;
                      if(RI)
                      {
                              RI = 0;
                              UartCharPro(ch);
                      }
              }
              /************************************************************
               * Name: UartCharPro
               * Func:
               *  字符处理过程函数。根据输入的普通字符或控制字符判断回显。
               * Para: 
               *  unsigned char ch: 判断的字符
               * Return: None
               ***********************************************************/
              void UartCharPro(unsigned char ch)
              {
                      switch(ch) 
C51 COMPILER V8.18   UART                                                                  08/13/2011 17:58:07 PAGE 3   

                      {
                      case '\b':    // 退格键
                                              if(g_ucCur > CMD_TAG)
                                              {
                                                      UartSendChar('\b');
                                              UartSendChar(' ');
                                                      UartSendChar('\b');
                                                      if(g_ucLen)
                                                      {
                                                      g_ucLen--;
                                                      }
                                                      g_ucCur--;
                                              }
                                              break;
                      case '\r':    // 回车键
                                              UartSendChar('\r');
                                              UartSendChar('\n');
                                              g_ucCmd[g_ucLen] = 0;
                                              UartSendStr(g_ucCmd);
                                              UartSendChar('\r');
                                              UartSendChar('\n');
                                              UartSendChar('>');
                                              g_ucLen = 0;
                                              g_ucCur = 1;
                                              break;
                      default:    // 其它字符
                                              UartSendChar(ch);
                
                                              g_ucCur++;
                                              if(g_ucLen < CMD_LEN)
                                              {
                                                      g_ucCmd[g_ucLen++] = ch;
                                              }
                                              else 
                                              {
                                                      g_ucCmd[g_ucLen] = 0;
                                              }
                      }
              }
              #endif
 158          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     61    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =      2    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
