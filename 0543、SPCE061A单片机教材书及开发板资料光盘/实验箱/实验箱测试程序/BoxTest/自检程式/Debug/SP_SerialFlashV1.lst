Sunplus u'nSP Assembler - Ver. 1.8.0

                            	//////////////////////////////////////////////////////////////////
                            	// File: sflash.asm    
                            	// Function: SERIAL Flash Interface with Serial Flash V1.1
                            	// Writen by: Honda
                            	// Modified by: Arthur Shieh
                            	// Modify list:
                            	//              2001/08/23 : first version
                            	//              2002/05/26 : Modified to use with DVR by Arthur Shieh
                            	//              2002/06/06 : API wrapping 
                            	// Note:
                            	//      1. Modify the C_SIOCLOCK to speed up the serial IO bus
                            	//      2. Modified the delay to shorten the waiting time for flash writing
                            	//////////////////////////////////////////////////////////////////
                            	
                            	.include hardware.inc;
                     <      	//========================================================================================
                     <      	// Progarm: The file be included by modules
                     <      	// Arranged by: Andy Hsu
                     <      	// Date: 	2000/06/23: first version
                     <      	//		2000/07/24: modified
                     <      	//		2000/10/20: modified for version 52A
                     <      	//========================================================================================
                     <      	//////////////////////////////////////////////////////////////////
                     <      	// Definitions for I/O Port
                     <      	//////////////////////////////////////////////////////////////////
                     <      	.DEFINE	P_IOA_Data   		0x7000;        // Write Data into data register and read from IOA pad
                     <      	.DEFINE P_IOA_Buffer        0x7001;        // Write Data into buffer register and read from buffer register
                     <      	.DEFINE P_IOA_Dir           0x7002;        // Direction vector for IOA
                     <      	.DEFINE P_IOA_Attrib        0x7003;        // Attribute vector for IOA
                     <      	.DEFINE P_IOA_Latch         0x7004;        // Latch PortA data for key change wake-up
                     <      	
                     <      	.DEFINE P_IOB_Data         	0x7005;        // Write Data into the data register and read from IOB pad
                     <      	.DEFINE P_IOB_Buffer        0x7006;        // Write Data into buffer register and read from buffer register
                     <      	.DEFINE P_IOB_Dir           0x7007;        // Direction vector for IOB
                     <      	.DEFINE P_IOB_Attrib        0x7008;        // Attribute vector for IOB
                     <      	
                     <      	.DEFINE P_FeedBack          0x7009;        // Clock form external R,C
                     <      	.DEFINE P_TimerA_Data       0x700A;        // Data port for TimerA 
                     <      	.DEFINE P_TimerA_Ctrl       0x700B;        // Control Port for TimerA
                     <      	.DEFINE P_TimerB_Data       0x700C;        // Data port for TimerB
                     <      	.DEFINE P_TimerB_Ctrl       0x700D;        // Control Port for TimerB
                     <      	.DEFINE P_TimeBase_Setup    0x700E;        // TimerBase Freq. Set
                     <      	.DEFINE P_TimeBase_Clear	0x700F;		   // Reset Timerbase counter
                     <      	.DEFINE P_INT_Ctrl          0x7010;        // Control port for interrupt source
                     <      	.DEFINE P_INT_Clear         0x7011;        // Clear interrupt source
                     <      	.DEFINE P_Watchdog_Clear    0x7012;        // Watchdog Reset
                     <      	.DEFINE P_SystemClock       0x7013;        // Change system clock frequency(include go to standby mode)
                     <      	
                     <      	//... PA6442 Old version (for EC-02) ...........
                     <      	//.DEFINE P_ADDA               0x7014;        //10-bit DA(W) AD(R)
                     <      	//.DEFINE P_DAC1               0x7014;        //
                     <      	//.DEFINE P_AD_Ctrl            0x7015;        //AD/DA control
                     <      	//.DEFINE P_AD_Status          0x7015;        //AD status
                     <      	//.DEFINE P_DAC2               0x7016;        //DAC channel 2
                     <      	//.DEFINE P_PWM                0x7016;        //PWM output
                     <      	//.DEFINE P_DA_Ctrl            0x7017;        //DAC latch control
                     <      	
                     <      	//... PA6442 New version MC52A (For EC-03)....
                     <      	.DEFINE P_ADC 	        	0x7014;        	// Data Port for AD
                     <      	.DEFINE P_ADC_Ctrl          0x7015;        	// Control Port for AD control
                     <      	.DEFINE P_ADC_Status        0x7015;        	// AD Port Status
                     <      	.DEFINE P_DAC2              0x7016;        	// Data Port for DAC2
                     <      	.DEFINE P_PWM               0x7016;        	// Data Port for PWM
                     <      	.DEFINE P_DAC1	        	0x7017;        	// Data Port for DAC1
                     <      	.DEFINE P_DAC_Ctrl			0x702A;			// Control Port for two DAC and audio output mode
                     <      	//............................................
                     <      	
                     <      	.DEFINE P_IR_Ctrl			0x7018;			// Control Port for IR
                     <      	.DEFINE P_LVD_Ctrl          0x7019;        	// Control Port for LVD
                     <      	
                     <      	.DEFINE P_SIO_Addr_Low		0x701B;			// Address Port low
                     <      	.DEFINE P_SIO_Addr_Mid		0x701C;			// Address Port middle
                     <      	.DEFINE P_SIO_Addr_High	 	0x701D;			// Address Port high
                     <      	.DEFINE P_SIO_Ctrl			0x701E;			// Control Port
                     <      	.DEFINE P_SIO_Start			0x701F;			// Start port for serial interface
                     <      	.DEFINE P_SIO_Stop			0x7020;			// Stop port for serial interface
                     <      	.DEFINE P_SIO_Data			0x701A;	
                     <      	.DEFINE P_UART_Command1		 0x7021;		// Command1 Port for UART
                     <      	.DEFINE P_UART_Command2		 0x7022;		// Command2 Port for UART
                     <      	.DEFINE P_UART_Data			 0x7023; 		// Data Port for UART
                     <      	.DEFINE	P_UART_BaudScalarLow 0x7024;		// Set Baud Rate scalar low
                     <      	.DEFINE	P_UART_BaudScalarHigh 0x7025;		// Set Baud Rate scalar high
                     <      	
                     <      	
                     <      	//... Definitions for P_INT_Ctrl ..............
                     <      	.DEFINE C_IRQ6_TMB2             0x0001;        	// Timer B IRQ6
                     <      	.DEFINE C_IRQ6_TMB1             0x0002;        	// Timer A IRQ6
                     <      	.DEFINE C_IRQ5_2Hz              0x0004;        	// 2Hz IRQ5
                     <      	.DEFINE C_IRQ5_4Hz              0x0008;        	// 4Hz IRQ5
                     <      	.DEFINE C_IRQ4_1KHz             0x0010;        	// 1024Hz IRQ4
                     <      	.DEFINE C_IRQ4_2KHz             0x0020;        	// 2048Hz IRQ4
                     <      	.DEFINE C_IRQ4_4KHz             0x0040;        	// 4096Hz IRQ4
                     <      	.DEFINE C_IRQ3_KEY              0x0080;        	// Key Change IRQ3
                     <      	.DEFINE C_IRQ3_EXT1             0x0100;        	// Ext1 IRQ3
                     <      	.DEFINE C_IRQ3_EXT2             0x0200;        	// Ext2 IRQ3
                     <      	.DEFINE C_IRQ2_TMB              0x0400;        	// Timer B IRQ2
                     <      	.DEFINE C_FIQ_TMB               0x0800;        	// Timer B FIQ
                     <      	.DEFINE C_IRQ1_TMA              0x1000;        	// Timer A IRQ1
                     <      	.DEFINE C_FIQ_TMA               0x2000;        	// Timer A FIQ
                     <      	.DEFINE C_IRQ0_PWM              0x4000;        	// PWM IRQ0
                     <      	.DEFINE C_FIQ_PWM               0x8000;        	// PWM FIQ
                     <      	
                     <      	// Definitions for P_TimerA/B_Ctrl ............                               
                     <      	.DEFINE	C_Fosc_2				0x0000;			// 
                     <      	.DEFINE	C_Fosc_256		    	0x0001;			//
                     <      	.DEFINE	C_32768Hz				0x0002;			//
                     <      	.DEFINE	C_8192Hz				0x0003;			//
                     <      	.DEFINE	C_4096Hz				0x0004;			//
                     <      	.DEFINE	C_A1					0x0005;			//
                     <      	.DEFINE C_A0					0x0006;			//
                     <      	.DEFINE C_Ext1					0x0007;			//
                     <      	
                     <      	.DEFINE	C_2048Hz				0x0000;			//
                     <      	.DEFINE	C_1024Hz				0x0008;			//
                     <      	.DEFINE	C_256Hz					0x0010;			//
                     <      	.DEFINE	C_TMB1Hz				0x0018;			//
                     <      	.DEFINE	C_4Hz					0x0020;			//
                     <      	.DEFINE	C_2Hz					0x0028;			//
                     <      	.DEFINE	C_B1					0x0030;			//
                     <      	.DEFINE	C_Ext2					0x0038;			//
                     <      	
                     <      	.DEFINE	C_Off					0x0000;			//
                     <      	.DEFINE C_D1					0x0040;			//
                     <      	.DEFINE C_D2					0x0080;			//
                     <      	.DEFINE C_D3					0x00C0;			//
                     <      	.DEFINE C_D4					0x0100;			//
                     <      	.DEFINE C_D5					0x0140;			//
                     <      	.DEFINE C_D6					0x0180;			//
                     <      	.DEFINE C_D7					0x01C0;			//
                     <      	.DEFINE C_D8					0x0200;			//
                     <      	.DEFINE C_D9					0x0240;			//
                     <      	.DEFINE C_D10					0x0280;			//
                     <      	.DEFINE C_D11					0x02C0;			//
                     <      	.DEFINE C_D12					0x0300;			//
                     <      	.DEFINE C_D13					0x0340;			//
                     <      	.DEFINE C_D14					0x0380;			//
                     <      	.DEFINE C_TA_Div_2				0x03C0;			// Timer A
                     <      	.DEFINE C_TB_Div_2				0x03C0;			// Timer B
                     <      	
                     <      	//... Definition for P_SystemClock ............
                     <      	.DEFINE C_Fosc					0x0000;			// b3..b0
                     <      	.DEFINE C_Fosc_Div_2			0x0001;			//
                     <      	.DEFINE C_Fosc_Div_4			0x0002;			//
                     <      	.DEFINE C_Fosc_Div_8			0x0003;			// (default)
                     <      	.DEFINE C_Fosc_Div_16			0x0004;			//
                     <      	.DEFINE C_Fosc_Div_32			0x0005;			//
                     <      	.DEFINE C_Fosc_Div_64			0x0006;			//
                     <      	.DEFINE C_Sleep					0x0007;		 	//
                     <      	
                     <      	.DEFINE	C_32K_Work				0x0000;			// b4
                     <      	.DEFINE C_32K_Off				0x0000;			// 
                     <      	.DEFINE C_StrongMode			0x0000;			// b5
                     <      	.DEFINE C_AutoMode				0x0000;			//
                     <      	
                     <      	//... Define for P_AD_Ctrl ....................
                     <      	.DEFINE	C_AD					0x0001;			//
                     <      	.DEFINE C_DA					0x0000;			//
                     <      	.DEFINE C_MIC					0x0000;			//
                     <      	.DEFINE C_LINE					0x0002;			//
                     <      	
                     <      	//... Define for P_DA_Ctrl ....................
                     <      	.DEFINE C_PushPull				0x0000;			// b0, (default) 
                     <      	.DEFINE C_DoubleEnd				0x0001;			// b0
                     <      	.DEFINE	C_DAC_Mode				0x0000;			// b1, (default)
                     <      	.DEFINE C_PWM_Mode				0x0002;			// b1
                     <      	
                     <      	.DEFINE	C_D1_Direct				0x0000;			// DAC1 latch
                     <      	.DEFINE C_D1_LatchA				0x0008;			// 
                     <      	.DEFINE C_D1_LatchB				0x0010;			//
                     <      	.DEFINE C_D1_LatchAB			0x0018;			//
                     <      	
                     <      	.DEFINE	C_D2_Direct				0x0000;			// DAC2 latch
                     <      	.DEFINE C_D2_LatchA				0x0020;			// 
                     <      	.DEFINE C_D2_LatchB				0x0040;			//
                     <      	.DEFINE C_D2_LatchAB			0x00C0;			//
                     <      	
                     <      	//... Define for P_LVD_Ctrl ...................
                     <      	.DEFINE C_LVD24V				0x0000;			// LVD = 2.4V 
                     <      	.DEFINE C_LVD28V				0x0001;			// LVD = 2.8V
                     <      	.DEFINE C_LVD32V				0x0002;			// LVD = 3.2V
                     <      	.DEFINE C_LVD36V				0x0003;			// LVD = 3.6V
                     <      	
                     <      	
                     <      	.EXTERNAL	F_SP_Read_INT_Status;			// for further use
                     <      	.EXTERNAL 	F_SP_Write_INT_Status;			// for further use
                     <      	.EXTERNAL  	F_SP_Set_INT_Vector;			// for further use
                     <      	.EXTERNAL	F_SP_Clear_INT_Vector;			// for further use
                     <      	
                     <      	.EXTERNAL	F_SP_Send_Out;					//
                     <      	.EXTERNAL	F_SP_Send_DAC1;					//
                     <      	.EXTERNAL	F_SP_Send_DAC2;					//
                     <      	.EXTERNAL	F_SP_Send_Two_DAC;				//
                     <      	.EXTERNAL	F_SP_Init_HW;					//
                     <      	
                     <      	.EXTERNAL	R_InterruptStatus;
                     <      	
                     <      	
                     <      	.EXTERNAL 	F_SP_RampUpDAC1;
                     <      	.EXTERNAL 	F_SP_RampDnDAC1;
                     <      	.EXTERNAL 	F_SP_RampUpDAC2;
                     <      	.EXTERNAL  	F_SP_RampDnDAC2;
                     <      	
                     <      	.EXTERNAL 	F_SP_InitQueue;
                     <      	.EXTERNAL 	F_SP_ReadQueue;
                     <      	.EXTERNAL 	F_SP_WriteQueue;
                     <      	.EXTERNAL 	F_SP_TestQueue;
                     <      	
                     <      	
                     <      	
                     <      	.EXTERNAL	F_SP_Get_ADC
                     <      	
                     <      	.EXTERNAL 	F_SP_Set_P_TimerA_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_TimerA_Data
                     <      	.EXTERNAL 	F_SP_Set_P_TimerB_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_TimerB_Data
                     <      	.EXTERNAL 	F_SP_Set_P_INT_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_INT_Clear
                     <      	.EXTERNAL 	F_SP_Set_P_SystemClock
                     <      	.EXTERNAL 	F_SP_Set_P_DAC_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_ADC_Ctrl
                     <      	
                     <      		
                     <      	
                     <      	//--------------------------------------------
                     <      	SACM_MACRO1: 	.MACRO
                     <      		
                     <      		.ENDM
                     <      	
                     <      	SACM_MACRO2:	.MACRO
                     <      		
                     <      		.ENDM
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	//.define PC_Play_Enable_A2000		1    	// Enable the PC-Play function for SACM-A2000 module
                     <      	//.define PC_Play_Enable_S480		1    	// Enable the PC-Play function for SACM-S480 module
                     <      	//.define PC_Play_Enable_S240		1    	// Enable the PC-Play function for SACM-S240 module    
                     <      	//.define PC_Play_Enable_MS01		1    	// Enable the PC-Play function for SACM-MS01 module
                     <      	
                     <      	
                     <      	
                     <      	//========================================================================================        
                     <      	// End of hardware.inc
                     <      	//========================================================================================
                            	
                            	.DEFINE C_SIOCLOCK           0x0010;        // CPUCLOCK/8
                            	
00000000                    	.CODE
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Send A Byte to Serial Flash
                            	// Syntax: SP_SIOSendAByte(AddressLow,AddressHigh,  data)
                            	// c level public
                            	// Used register: r1,r2,r3
                            	//////////////////////////////////////////////////////////////////
                            	.public _SP_SIOSendAByte;
                            	_SP_SIOSendAByte: .PROC
                            	F_SIOSendAByte:
00000000 88 DA              	    PUSH BP,BP TO [SP];
00000001 08 0B 01 00        	    BP = SP + 1;
00000003 03 92              		R1 = [BP+3];
00000004 19 D3 1B 70        	    [P_SIO_Addr_Low]=r1;        // input SFLASH low address
00000006 79 93              	    r1=r1 lsr 4;         		// right shift 8
00000007 79 93              	    r1=r1 lsr 4;
00000008 19 D3 1C 70        	    [P_SIO_Addr_Mid]=r1; 		// input SFLASH mid address
0000000A 04 92              	    R1 = [BP+4];                // Port direction
0000000B 47 B2              	    r1=r1&0x0007;  				// input SFLASH hi address
0000000C 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
0000000E 09 93 D3 00        	        r1=0x00C3+C_SIOCLOCK;
00000010 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;        // clk=CPUclk/8, 24 bit address  ;write
00000012 19 D3 1F 70        	        [P_SIO_Start]=r1;       // enable write mode
00000014 05 92              	        R1 = [BP+5];
00000015 19 D3 1A 70        	        [P_SIO_Data]=r1;        // state to transmit data
                            	L_WaitSIOSendReady:
00000017 11 93 1F 70        	        r1=[P_SIO_Start];
00000019 09 C3 80 00        	        test    r1,0x0080
0000001B 45 4E              	        jne     L_WaitSIOSendReady
0000001C 19 D3 20 70        	        [P_SIO_Stop]=r1;                   //disable write mode
0000001E 88 98              	        POP BP,BP FROM [SP];
0000001F 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Read A Byte to Serial Flash
                            	// Syntax: SP_SIOReadAByte(AddressLow, AddressHigh)
                            	// c level public
                            	// Used register: r1,r2,r3
                            	// Return register: r1
                            	//////////////////////////////////////////////////////////////////         
                            	
                            	.public _SP_SIOReadAByte;
                            	_SP_SIOReadAByte: .PROC
                            	F_SIOReadAByte:
00000020 88 DA              	                PUSH BP,BP TO [SP];
00000021 08 0B 01 00        	        BP = SP + 1;
00000023 03 92              	        R1 = [BP+3];
00000024 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 		// input SFLASH low address
00000026 79 93              	        r1=r1 lsr 4;
00000027 79 93              	        r1=r1 lsr 4;
00000028 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1; 		// input SFLASH mid address
0000002A 04 92              	        R1 = [BP+4];                // Port direction
0000002B 47 B2              	        r1=r1&0x0007;  				// input SFLASH hi address
0000002C 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
0000002E 09 93 93 00        	        r1=0x0083+C_SIOCLOCK;
00000030 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;            // clk=CPUclk/16, 24 bit address  ;read
00000032 19 D3 1F 70        	        [P_SIO_Start]=r1;           // enable read mode
00000034 12 95 1A 70        	        r2=[P_SIO_Data];            // Clear SFLASH buffer
                            	L_WaitSIOReadReady1:
00000036 11 93 1F 70        	        r1=[P_SIO_Start];
00000038 09 C3 80 00        	        test    r1,0x0080
0000003A 45 4E              	        jne     L_WaitSIOReadReady1
0000003B 11 93 1A 70        	        r1=[P_SIO_Data];          	// Read exact Data
                            	L_WaitSIOReadReady2:                // Wait read stop
0000003D 12 95 1F 70        	        r2=[P_SIO_Start];
0000003F 0A C5 80 00        	        test    r2,0x0080
00000041 45 4E              	        jne     L_WaitSIOReadReady2
00000042 1A D5 20 70        	        [P_SIO_Stop]=r2;            // disable read mode
00000044 88 98              	        POP BP,BP FROM [SP];
00000045 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Send A Word to Serial Flash
                            	// Syntax: SP_SIOSendAData(AddressLow,AddressHigh,  data) Address must be even
                            	// c level public
                            	// Used register: r1,r2,r3
                            	//////////////////////////////////////////////////////////////////
                            	.public _SP_SIOSendAWord;
                            	_SP_SIOSendAWord: .PROC
                            	F_SIOSendAWord:
00000046 88 DA              	        PUSH BP,BP TO [SP];
00000047 08 0B 01 00        	        BP = SP + 1;
                            	//        PUSH r1,r3 TO [SP];
00000049 09 93 D3 00        	        r1=0x00C3+C_SIOCLOCK;
0000004B 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;            // clk=CPUclk/8, 24 bit address  ;write
0000004D 03 92              	        R1 = [BP+3];
0000004E 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1;  		// input Sflash low address
00000050 79 93              	        r1=r1 lsr 4;          		// right shift 8
00000051 79 93              	        r1=r1 lsr 4;
00000052 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1;  		// input SFLASH mid address
00000054 04 92              	        R1 = [BP+4];                // Port direction
00000055 47 B2              	        r1=r1&0x0007;  				// input SFLASH hi address
00000056 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
                            	        
00000058 19 D3 1F 70        	        [P_SIO_Start]=r1;           // enable write mode
0000005A 05 92              	        R1 = [BP+5];
0000005B 19 D3 1A 70        	        [P_SIO_Data]=r1;            //start to transmit low byte
                            	L_WaitSIOSendReadyLB:
0000005D 11 93 1F 70        	        r1=[P_SIO_Start];
0000005F 09 C3 80 00        	        test    r1,0x0080
00000061 45 4E              	        jne     L_WaitSIOSendReadyLB
00000062 40 F0 13 01        	        call    F_DelayPT           // Delay necessary for the writing   
00000064 40 F0 13 01        	        call    F_DelayPT 
00000066 40 F0 13 01        	        call    F_DelayPT 
00000068 40 F0 13 01        	        call    F_DelayPT            
                            	     //   call    F_DelayPT            
                            	     //   call    F_DelayPT            
                            	        
0000006A 19 D3 20 70        	        [P_SIO_Stop]=r1;            // disable write mode
0000006C 03 92              	         R1 = [BP+3];
0000006D 41 02              	         r1+=1;
0000006E 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 		// input SFLASH low address
                            	             
00000070 19 D3 1F 70        	        [P_SIO_Start]=r1;           //enable write mode
00000072 05 92              	        r1=[BP+5]; 
00000073 79 93              	        r1=r1 lsr 4;         		// right shift 8
00000074 79 93              	        r1=r1 lsr 4;
00000075 19 D3 1A 70        	        [P_SIO_Data]=r1;            //start to transmit high byte
                            	L_WaitSIOSendReadyHB:
00000077 11 93 1F 70        	        r1=[P_SIO_Start];
00000079 09 C3 80 00        	        test    r1,0x0080
0000007B 45 4E              	        jne     L_WaitSIOSendReadyHB
0000007C 40 F0 13 01        	     	call    F_DelayPT          
0000007E 40 F0 13 01        	      	call    F_DelayPT          
00000080 40 F0 13 01        	        call    F_DelayPT
00000082 40 F0 13 01        	        call    F_DelayPT
00000084 19 D3 20 70        	        [P_SIO_Stop]=r1;            //disable write mode
                            	//        POP r1,r3 FROM [SP];
00000086 88 98              	        POP BP,BP FROM [SP];
00000087 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Read A Word from Serial Flash
                            	// Syntax: SP_SIOReadAWord(AddressLow, AddressHigh)
                            	// c level public
                            	// Used register: r1,r2,r3,r4
                            	// Return register: r1
                            	//////////////////////////////////////////////////////////////////         
                            	
                            	.public _SP_SIOReadAWord;
                            	_SP_SIOReadAWord: .PROC
                            	F_SIOReadAWord:
00000088 88 DA              	        PUSH BP,BP TO [SP];
00000089 08 0B 01 00        	        BP = SP + 1;
                            	      //  PUSH r2,r4 TO [SP];   modify by 
0000008B 0C 99 FF 00        	        r4=0x00FF;
0000008D 03 92              	        R1 = [BP+3];
0000008E 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 		// input SFLASH low address
00000090 79 93              	        r1=r1 lsr 4;
00000091 79 93              	        r1=r1 lsr 4;
00000092 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1; 		// input SFLASH mid address
00000094 04 92              	        R1 = [BP+4];                // Port direction
00000095 47 B2              	        r1=r1&0x0007;  				// input SFLASH hi address
00000096 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
                            	     //   r1=0x0083+C_SIOCLOCK;       // C_SIOCLOCK 0x0010
00000098 09 93 83 00        	        r1=0x0083;    //+C_SIOCLOCK;       // C_SIOCLOCK 0x0010
0000009A 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;           	// clk=CPUclk/16, 24 bit address  ;read
0000009C 19 D3 1F 70        	        [P_SIO_Start]=r1;       	// enable read mode
                            	        ////////
0000009E 12 95 1A 70        	        r2=[P_SIO_Data];          	// Clear SFLASH buffer
                            	        ////////
                            	L_WaitSIOReadReady1LB:
000000A0 11 93 1F 70        	        r1=[P_SIO_Start];
000000A2 09 C3 80 00        	        test    r1,0x0080
000000A4 45 4E              	        jne     L_WaitSIOReadReady1LB
                            	        
                            	        
                            	        
000000A5 14 B5 1A 70        	        r2=r4&[P_SIO_Data];          // Read exact Low Byte
                            	L_WaitSIOReadReady2LB:               // Wait read stop
000000A7 11 93 1F 70        	        r1=[P_SIO_Start];
000000A9 09 C3 80 00        	        test    r1,0x0080
000000AB 45 4E              	        jne     L_WaitSIOReadReady2LB
                            	        
                            	        
000000AC 14 B7 1A 70        	        r3=r4&[P_SIO_Data];          // Read exact High Byte
                            	
                            	L_WaitSIOReadReady2HB:               // Wait read stop
000000AE 11 93 1F 70        	        r1=[P_SIO_Start];
000000B0 09 C3 80 00        	        test    r1,0x0080
000000B2 45 4E              	        jne     L_WaitSIOReadReady2HB
                            	       
000000B3 19 D3 20 70        	        [P_SIO_Stop]=r1;             // disable read mode
                            	 
000000B5 5B 97              	        r3=r3 lsl 4;     //shift left 8
000000B6 5B 93              	        r1=r3 lsl 4;
000000B7 02 A3              	        r1|=r2;         //return data
                            	       // POP r2,r4 FROM [SP];
000000B8 88 98              	        POP BP,BP FROM [SP];
000000B9 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Page Erase for S_Flash (Page Size 1K)
                            	// Syntax: SP_SIOPageErase(Page)
                            	// Used register: r1,r2
                            	///////////////////////////////////////////////////////////////
                            	.public _SP_SIOPageErase;
                            	_SP_SIOPageErase: .PROC
                            	F_SIOPageErase:
000000BA 88 DA              	                PUSH BP,BP TO [SP];
000000BB 08 0B 01 00        	        BP = SP + 1;
                            	 
000000BD 03 92              	        R1 = [BP+3];
000000BE 49 93              	        r1=r1 lsl 2;      		// 1K page size
000000BF 09 B3 FF 01        	        r1=r1&0x01FF;
000000C1 09 A3 00 80        	        r1=r1|0x8000;
000000C3 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 	// input SFLASH low address ;for A15 and A10
000000C5 79 93              	        r1=r1 lsr 4;
000000C6 79 93              	        r1=r1 lsr 4;
000000C7 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1; 	// input SFLASH mid address ;for A16
000000C9 09 93 D0 00        	        r1=0x00C0+C_SIOCLOCK;
000000CB 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;        // clk=CPUclk/8, 16 bit address  ;write
000000CD 19 D3 1F 70        	        [P_SIO_Start]=r1;       // enable write mode
000000CF 40 92              	        r1=0;                   // A7~A0 = 0
000000D0 19 D3 1A 70        	        [P_SIO_Data]=r1;        // state to transmit data
                            	
                            	L_WaitSIOSendReadyPage:
000000D2 11 93 1F 70        	        r1=[P_SIO_Start];
000000D4 09 C3 80 00        	        test    r1,0x0080
000000D6 45 4E              	        jne     L_WaitSIOSendReadyPage
000000D7 19 D3 20 70        	        [P_SIO_Stop]=r1;         //disable write mode
                            	
000000D9 40 F0 03 01        	        call    F_Delay11ms
                            	        
000000DB 88 98              	        POP BP,BP FROM [SP];
000000DC 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Mass Erase for S_Flash
                            	// Syntax: SIOMassErase()
                            	// Used register: r1,r2
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _SP_SIOMassErase;
                            	_SP_SIOMassErase: .PROC
                            	F_SIOMassErase:
000000DD 90 D4              	        push r1,r2 to [sp];
000000DE 09 93 D0 00        	        r1=0x00C0+C_SIOCLOCK;
000000E0 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;            // clk=CPUclk/8, 16 bit address  ;write
000000E2 40 94              	        r2=0x0000;
000000E3 1A D5 1B 70        	        [P_SIO_Addr_Low]=r2; 		// input SFLASH low address
000000E5 0A 95 C0 00        	        r2=0x00C0;
000000E7 1A D5 1C 70        	        [P_SIO_Addr_Mid]=r2; 		// input SFLASH mid address
000000E9 0A 95 C0 00        	        r2=0x00C0;
000000EB 1A D5 1D 70        	       [P_SIO_Addr_High]=r2; 
                            	//        r1=0x00C0+C_SIOCLOCK;
                            	  //      [P_SIO_Ctrl]=r1;            // clk=CPUclk/8, 16 bit address  ;write
000000ED 19 D3 1F 70        	        [P_SIO_Start]=r1;           // enable write mode
000000EF 40 92              	        r1=0;                       // A7~A0 = 0
000000F0 19 D3 1A 70        	        [P_SIO_Data]=r1;            // state to transmit data
                            	
                            	L_WaitSIOSendReadyMass:
000000F2 11 93 1F 70        	        r1=[P_SIO_Start];
000000F4 09 C3 80 00        	        test    r1,0x0080
000000F6 45 4E              	        jne     L_WaitSIOSendReadyMass
                            	                      //disable write mode
000000F7 19 D3 20 70        			[P_SIO_Stop]=r1;
                            	
000000F9 40 F0 03 01        	        call    F_Delay11ms
000000FB 40 F0 03 01        	        call    F_Delay11ms      
000000FD 40 F0 03 01        	        call    F_Delay11ms
000000FF 40 F0 03 01        	        call    F_Delay11ms
00000101 90 90              	        pop r1,r2 from [sp];
00000102 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	F_Delay11ms:
00000103 88 D2              	        push r1,r1 to [sp];
                            	        //r1=17*10;
00000104 09 93 C8 00        	        r1=20*10;  // delay 
                            	L_LoopDelay11:
00000106 40 F0 0C 01        	        call    F_Delay100uS;
00000108 41 22              	        r1-=1;
00000109 44 4E              	        jne     L_LoopDelay11
0000010A 88 90              	        pop r1,r1 from [sp];
0000010B 90 9A              	        retf;
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : 100us Dealy for S_Flash programming time (base on CPUCLK= 24MHz)
                            	// Syntax: Delay100uS()
                            	// Used register: r1,r2
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _Delay100uS;
                            	_Delay100uS: .PROC
                            	F_Delay100uS:  //13
0000010C 88 D2              	        push r1,r1 to [sp];             //7
0000010D 09 93 26 01        	        r1=294;  //6
                            	L_DelayLoop:
0000010F 41 22              	        r1-=1;  //3           26+19+8*294 =2400
00000110 42 4E              	        jne     L_DelayLoop;   //5
00000111 88 90              	        pop r1,r1 from [sp];    //7
00000112 90 9A              	        retf;      //12
                            	        .ENDP;
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Dealy for S_Flash programming time (base on CPUCLK= 24MHz)
                            	// Syntax: DelayPT()
                            	// Used register: r1
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _DelayPT;
                            	_DelayPT: .PROC
                            	F_DelayPT:  //13
00000113 88 D2              	        push r1,r1 to [sp];             //7
                            	        //r1=294;  //6
                            	        //r1=147;
                            	        //r1=1600;
                            	        //r1=100;
00000114 09 93 A0 00        	        r1=160
                            	        //r1=200;
                            	L_DelayLoopPT:
00000116 41 22              	        r1-=1;  //3           26+19+8*160 =1325  ----> 56us
00000117 42 4E              	        jne     L_DelayLoopPT;   //5
00000118 88 90              	        pop r1,r1 from [sp];    //7
00000119 90 9A              	        retf;      //12
                            	        .ENDP;
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Write head. There are 8 bytes. The first 4 bytes is address of ending speech
                            	//           The last 4 bytes is 1' complement of first 4 bytes
                            	// Syntax  : SP_WriteHeader( Low Address of header, High Address of header, DataLow, DataHigh)
                            	// Used register: r1-r3
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _SP_WriteHeader;
                            	_SP_WriteHeader: .PROC
                            	F_WriteHeader:
0000011A 88 DA              	        PUSH BP,BP TO [SP];
0000011B 08 0B 01 00        	        BP = SP + 1;
0000011D 05 96              	        r3=[BP+5];  //data for programming
0000011E 04 94              	        r2=[BP+4];  //high addr for programming
0000011F 03 92              	        r1=[BP+3];  //low addr for programming
00000120 98 D6              	        PUSH r1,r3 TO [SP];
00000121 40 F0 46 00        	        call    F_SIOSendAWord;
00000123 98 90              	        pop r1,r3 from [SP];
00000124 06 96              	        r3=[BP+6];  //data for programming
00000125 04 94              	        r2=[BP+4];  //high addr for programming
00000126 03 92              	        r1=[BP+3];  //low addr for programming
00000127 42 02              	        r1+=2;
00000128 40 14              	        r2+=0, carry;
00000129 98 D6              	        PUSH r1,r3 TO [SP];
0000012A 40 F0 46 00        	        call    F_SIOSendAWord;
0000012C 98 90              	        pop r1,r3 from [SP];
0000012D 05 96              	        r3=[BP+5];  //data for programming
0000012E 0B 87 FF FF        	        r3^=0xffff;
00000130 04 94              	        r2=[BP+4];  //high addr for programming
00000131 03 92              	        r1=[BP+3];  //low addr for programming
00000132 44 02              	        r1+=4;
00000133 40 14              	        r2+=0, carry;
00000134 98 D6              	        PUSH r1,r3 TO [SP];
00000135 40 F0 46 00        	        call    F_SIOSendAWord;
00000137 98 90              	        pop r1,r3 from [SP];
00000138 06 96              	        r3=[BP+6];  //data for programming
00000139 0B 87 FF FF        	        r3^=0xffff;
0000013B 04 94              	        r2=[BP+4];  //high addr for programming
0000013C 03 92              	        r1=[BP+3];  //low addr for programming
0000013D 46 02              	        r1+=6;
0000013E 40 14              	        r2+=0, carry;
0000013F 98 D6              	        PUSH r1,r3 TO [SP];
00000140 40 F0 46 00        	        call    F_SIOSendAWord;
00000142 98 90              	        pop r1,r3 from [SP];
00000143 88 98              	        POP BP,BP FROM [SP];
00000144 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Check header. Header has 8 bytes. The first 4 bytes is address of ending speech
                            	//           The last 4 bytes is 1' complement of first 4 bytes
                            	// Syntax  : CheckHeader( Low Address of header, High Address of header)
                            	// Used register: r1
                            	// return value : r1, r2  (if r1=0xffff and r2=0xffff, error)
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _SP_CheckHeader;
                            	_SP_CheckHeader: .PROC
                            	F_CheckHeader:
00000145 88 DA              	        PUSH BP,BP TO [SP];
00000146 08 0B 01 00        	        BP = SP + 1;
00000148 04 96              	        r3=[BP+4];  //high addr for reading
00000149 03 94              	        r2=[BP+3];  //low addr for reading
0000014A 42 04              	        r2+=2;
0000014B 40 16              	        r3+=0, carry;
0000014C 98 D8              	        PUSH r2,r4 TO [SP];
0000014D 40 F0 88 00        	        call    F_SIOReadAWord;
0000014F 98 92              	        pop r2,r4 from [SP];
00000150 01 99              	        r4=r1;
00000151 04 96              	        r3=[BP+4];  //high addr for reading
00000152 03 94              	        r2=[BP+3];  //low addr for reading
00000153 46 04              	        r2+=6;
00000154 40 16              	        r3+=0, carry;
00000155 98 D8              	        PUSH r2,r4 TO [SP];
00000156 40 F0 88 00        	        call    F_SIOReadAWord;
00000158 98 92              	        pop r2,r4 from [SP];
00000159 09 83 FF FF        	        r1^=0xffff;
0000015B 04 43              	        cmp r1,r4
0000015C 18 4E              	        jne L_HeaderError
0000015D 88 D8              	        PUSH r4,r4 TO [SP];     //save high byte of return data
0000015E 04 96              	        r3=[BP+4];  //high addr for reading
0000015F 03 94              	        r2=[BP+3];  //low addr for reading
00000160 98 D8              	        PUSH r2,r4 TO [SP];
00000161 40 F0 88 00        	        call    F_SIOReadAWord;
00000163 98 92              	        pop r2,r4 from [SP];
00000164 01 99              	        r4=r1;
00000165 04 96              	        r3=[BP+4];  //high addr for reading
00000166 03 94              	        r2=[BP+3];  //low addr for reading
00000167 44 04              	        r2+=4;
00000168 40 16              	        r3+=0, carry;
00000169 98 D8              	        PUSH r2,r4 TO [SP];
0000016A 40 F0 88 00        	        call    F_SIOReadAWord;
0000016C 98 92              	        pop r2,r4 from [SP];
0000016D 09 83 FF FF        	        r1^=0xffff;
0000016F 04 43              	        cmp r1,r4
00000170 03 4E              	        jne  L_HeaderError2
00000171 88 92              	        POP r2,r2 FROM [SP];     //get high byte of return data
00000172 88 98              	        POP BP,BP FROM [SP];
00000173 90 9A              	        retf;
                            	
                            	L_HeaderError2:
00000174 88 96              	        POP r4,r4 FROM [SP];     //remove high byte of return data
                            	
                            	L_HeaderError:
00000175 09 93 FF FF        	        r1=0xffff;
00000177 0A 95 FF FF        	        r2=0xffff;
00000179 88 98              	        POP BP,BP FROM [SP];
                            	        .ENDP;
                            	
                            	
                            	
                            	
0 error(s), 0 warning(s).
