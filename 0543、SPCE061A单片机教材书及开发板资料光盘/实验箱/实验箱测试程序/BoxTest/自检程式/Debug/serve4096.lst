Sunplus u'nSP Assembler - Ver. 1.8.0
              Listing File Has Been Relocated
                            	//////////////////////////////////////////////////////////////////
                            	// File: sflash.asm    
                            	// Function: SERIAL Flash Interface with Serial Flash V1.1
                            	// Writen by: Honda
                            	// Modified by: Arthur Shieh
                            	// Modify list:
                            	//              2001/08/23 : first version
                            	//              2002/05/26 : Modified to use with DVR by Arthur Shieh
                            	//              2002/06/06 : API wrapping 
                            	// Note:
                            	//      1. Modify the C_SIOCLOCK to speed up the serial IO bus
                            	//      2. Modified the delay to shorten the waiting time for flash writing
                            	//////////////////////////////////////////////////////////////////
                            	
                            	.include hardware.inc;
                     <      	//========================================================================================
                     <      	// Progarm: The file be included by modules
                     <      	// Arranged by: Andy Hsu
                     <      	// Date: 	2000/06/23: first version
                     <      	//		2000/07/24: modified
                     <      	//		2000/10/20: modified for version 52A
                     <      	//========================================================================================
                     <      	//////////////////////////////////////////////////////////////////
                     <      	// Definitions for I/O Port
                     <      	//////////////////////////////////////////////////////////////////
                     <      	.DEFINE	P_IOA_Data   		0x7000;        // Write Data into data register and read from IOA pad
                     <      	.DEFINE P_IOA_Buffer        0x7001;        // Write Data into buffer register and read from buffer register
                     <      	.DEFINE P_IOA_Dir           0x7002;        // Direction vector for IOA
                     <      	.DEFINE P_IOA_Attrib        0x7003;        // Attribute vector for IOA
                     <      	.DEFINE P_IOA_Latch         0x7004;        // Latch PortA data for key change wake-up
                     <      	
                     <      	.DEFINE P_IOB_Data         	0x7005;        // Write Data into the data register and read from IOB pad
                     <      	.DEFINE P_IOB_Buffer        0x7006;        // Write Data into buffer register and read from buffer register
                     <      	.DEFINE P_IOB_Dir           0x7007;        // Direction vector for IOB
                     <      	.DEFINE P_IOB_Attrib        0x7008;        // Attribute vector for IOB
                     <      	
                     <      	.DEFINE P_FeedBack          0x7009;        // Clock form external R,C
                     <      	.DEFINE P_TimerA_Data       0x700A;        // Data port for TimerA 
                     <      	.DEFINE P_TimerA_Ctrl       0x700B;        // Control Port for TimerA
                     <      	.DEFINE P_TimerB_Data       0x700C;        // Data port for TimerB
                     <      	.DEFINE P_TimerB_Ctrl       0x700D;        // Control Port for TimerB
                     <      	.DEFINE P_TimeBase_Setup    0x700E;        // TimerBase Freq. Set
                     <      	.DEFINE P_TimeBase_Clear	0x700F;		   // Reset Timerbase counter
                     <      	.DEFINE P_INT_Ctrl          0x7010;        // Control port for interrupt source
                     <      	.DEFINE P_INT_Clear         0x7011;        // Clear interrupt source
                     <      	.DEFINE P_Watchdog_Clear    0x7012;        // Watchdog Reset
                     <      	.DEFINE P_SystemClock       0x7013;        // Change system clock frequency(include go to standby mode)
                     <      	
                     <      	//... PA6442 Old version (for EC-02) ...........
                     <      	//.DEFINE P_ADDA               0x7014;        //10-bit DA(W) AD(R)
                     <      	//.DEFINE P_DAC1               0x7014;        //
                     <      	//.DEFINE P_AD_Ctrl            0x7015;        //AD/DA control
                     <      	//.DEFINE P_AD_Status          0x7015;        //AD status
                     <      	//.DEFINE P_DAC2               0x7016;        //DAC channel 2
                     <      	//.DEFINE P_PWM                0x7016;        //PWM output
                     <      	//.DEFINE P_DA_Ctrl            0x7017;        //DAC latch control
                     <      	
                     <      	//... PA6442 New version MC52A (For EC-03)....
                     <      	.DEFINE P_ADC 	        	0x7014;        	// Data Port for AD
                     <      	.DEFINE P_ADC_Ctrl          0x7015;        	// Control Port for AD control
                     <      	.DEFINE P_ADC_Status        0x7015;        	// AD Port Status
                     <      	.DEFINE P_DAC2              0x7016;        	// Data Port for DAC2
                     <      	.DEFINE P_PWM               0x7016;        	// Data Port for PWM
                     <      	.DEFINE P_DAC1	        	0x7017;        	// Data Port for DAC1
                     <      	.DEFINE P_DAC_Ctrl			0x702A;			// Control Port for two DAC and audio output mode
                     <      	//............................................
                     <      	
                     <      	.DEFINE P_IR_Ctrl			0x7018;			// Control Port for IR
                     <      	.DEFINE P_LVD_Ctrl          0x7019;        	// Control Port for LVD
                     <      	
                     <      	.DEFINE P_SIO_Addr_Low		0x701B;			// Address Port low
                     <      	.DEFINE P_SIO_Addr_Mid		0x701C;			// Address Port middle
                     <      	.DEFINE P_SIO_Addr_High	 	0x701D;			// Address Port high
                     <      	.DEFINE P_SIO_Ctrl			0x701E;			// Control Port
                     <      	.DEFINE P_SIO_Start			0x701F;			// Start port for serial interface
                     <      	.DEFINE P_SIO_Stop			0x7020;			// Stop port for serial interface
                     <      	.DEFINE P_SIO_Data			0x701A;	
                     <      	.DEFINE P_UART_Command1		 0x7021;		// Command1 Port for UART
                     <      	.DEFINE P_UART_Command2		 0x7022;		// Command2 Port for UART
                     <      	.DEFINE P_UART_Data			 0x7023; 		// Data Port for UART
                     <      	.DEFINE	P_UART_BaudScalarLow 0x7024;		// Set Baud Rate scalar low
                     <      	.DEFINE	P_UART_BaudScalarHigh 0x7025;		// Set Baud Rate scalar high
                     <      	
                     <      	
                     <      	//... Definitions for P_INT_Ctrl ..............
                     <      	.DEFINE C_IRQ6_TMB2             0x0001;        	// Timer B IRQ6
                     <      	.DEFINE C_IRQ6_TMB1             0x0002;        	// Timer A IRQ6
                     <      	.DEFINE C_IRQ5_2Hz              0x0004;        	// 2Hz IRQ5
                     <      	.DEFINE C_IRQ5_4Hz              0x0008;        	// 4Hz IRQ5
                     <      	.DEFINE C_IRQ4_1KHz             0x0010;        	// 1024Hz IRQ4
                     <      	.DEFINE C_IRQ4_2KHz             0x0020;        	// 2048Hz IRQ4
                     <      	.DEFINE C_IRQ4_4KHz             0x0040;        	// 4096Hz IRQ4
                     <      	.DEFINE C_IRQ3_KEY              0x0080;        	// Key Change IRQ3
                     <      	.DEFINE C_IRQ3_EXT1             0x0100;        	// Ext1 IRQ3
                     <      	.DEFINE C_IRQ3_EXT2             0x0200;        	// Ext2 IRQ3
                     <      	.DEFINE C_IRQ2_TMB              0x0400;        	// Timer B IRQ2
                     <      	.DEFINE C_FIQ_TMB               0x0800;        	// Timer B FIQ
                     <      	.DEFINE C_IRQ1_TMA              0x1000;        	// Timer A IRQ1
                     <      	.DEFINE C_FIQ_TMA               0x2000;        	// Timer A FIQ
                     <      	.DEFINE C_IRQ0_PWM              0x4000;        	// PWM IRQ0
                     <      	.DEFINE C_FIQ_PWM               0x8000;        	// PWM FIQ
                     <      	
                     <      	// Definitions for P_TimerA/B_Ctrl ............                               
                     <      	.DEFINE	C_Fosc_2				0x0000;			// 
                     <      	.DEFINE	C_Fosc_256		    	0x0001;			//
                     <      	.DEFINE	C_32768Hz				0x0002;			//
                     <      	.DEFINE	C_8192Hz				0x0003;			//
                     <      	.DEFINE	C_4096Hz				0x0004;			//
                     <      	.DEFINE	C_A1					0x0005;			//
                     <      	.DEFINE C_A0					0x0006;			//
                     <      	.DEFINE C_Ext1					0x0007;			//
                     <      	
                     <      	.DEFINE	C_2048Hz				0x0000;			//
                     <      	.DEFINE	C_1024Hz				0x0008;			//
                     <      	.DEFINE	C_256Hz					0x0010;			//
                     <      	.DEFINE	C_TMB1Hz				0x0018;			//
                     <      	.DEFINE	C_4Hz					0x0020;			//
                     <      	.DEFINE	C_2Hz					0x0028;			//
                     <      	.DEFINE	C_B1					0x0030;			//
                     <      	.DEFINE	C_Ext2					0x0038;			//
                     <      	
                     <      	.DEFINE	C_Off					0x0000;			//
                     <      	.DEFINE C_D1					0x0040;			//
                     <      	.DEFINE C_D2					0x0080;			//
                     <      	.DEFINE C_D3					0x00C0;			//
                     <      	.DEFINE C_D4					0x0100;			//
                     <      	.DEFINE C_D5					0x0140;			//
                     <      	.DEFINE C_D6					0x0180;			//
                     <      	.DEFINE C_D7					0x01C0;			//
                     <      	.DEFINE C_D8					0x0200;			//
                     <      	.DEFINE C_D9					0x0240;			//
                     <      	.DEFINE C_D10					0x0280;			//
                     <      	.DEFINE C_D11					0x02C0;			//
                     <      	.DEFINE C_D12					0x0300;			//
                     <      	.DEFINE C_D13					0x0340;			//
                     <      	.DEFINE C_D14					0x0380;			//
                     <      	.DEFINE C_TA_Div_2				0x03C0;			// Timer A
                     <      	.DEFINE C_TB_Div_2				0x03C0;			// Timer B
                     <      	
                     <      	//... Definition for P_SystemClock ............
                     <      	.DEFINE C_Fosc					0x0000;			// b3..b0
                     <      	.DEFINE C_Fosc_Div_2			0x0001;			//
                     <      	.DEFINE C_Fosc_Div_4			0x0002;			//
                     <      	.DEFINE C_Fosc_Div_8			0x0003;			// (default)
                     <      	.DEFINE C_Fosc_Div_16			0x0004;			//
                     <      	.DEFINE C_Fosc_Div_32			0x0005;			//
                     <      	.DEFINE C_Fosc_Div_64			0x0006;			//
                     <      	.DEFINE C_Sleep					0x0007;		 	//
                     <      	
                     <      	.DEFINE	C_32K_Work				0x0000;			// b4
                     <      	.DEFINE C_32K_Off				0x0000;			// 
                     <      	.DEFINE C_StrongMode			0x0000;			// b5
                     <      	.DEFINE C_AutoMode				0x0000;			//
                     <      	
                     <      	//... Define for P_AD_Ctrl ....................
                     <      	.DEFINE	C_AD					0x0001;			//
                     <      	.DEFINE C_DA					0x0000;			//
                     <      	.DEFINE C_MIC					0x0000;			//
                     <      	.DEFINE C_LINE					0x0002;			//
                     <      	
                     <      	//... Define for P_DA_Ctrl ....................
                     <      	.DEFINE C_PushPull				0x0000;			// b0, (default) 
                     <      	.DEFINE C_DoubleEnd				0x0001;			// b0
                     <      	.DEFINE	C_DAC_Mode				0x0000;			// b1, (default)
                     <      	.DEFINE C_PWM_Mode				0x0002;			// b1
                     <      	
                     <      	.DEFINE	C_D1_Direct				0x0000;			// DAC1 latch
                     <      	.DEFINE C_D1_LatchA				0x0008;			// 
                     <      	.DEFINE C_D1_LatchB				0x0010;			//
                     <      	.DEFINE C_D1_LatchAB			0x0018;			//
                     <      	
                     <      	.DEFINE	C_D2_Direct				0x0000;			// DAC2 latch
                     <      	.DEFINE C_D2_LatchA				0x0020;			// 
                     <      	.DEFINE C_D2_LatchB				0x0040;			//
                     <      	.DEFINE C_D2_LatchAB			0x00C0;			//
                     <      	
                     <      	//... Define for P_LVD_Ctrl ...................
                     <      	.DEFINE C_LVD24V				0x0000;			// LVD = 2.4V 
                     <      	.DEFINE C_LVD28V				0x0001;			// LVD = 2.8V
                     <      	.DEFINE C_LVD32V				0x0002;			// LVD = 3.2V
                     <      	.DEFINE C_LVD36V				0x0003;			// LVD = 3.6V
                     <      	
                     <      	
                     <      	.EXTERNAL	F_SP_Read_INT_Status;			// for further use
                     <      	.EXTERNAL 	F_SP_Write_INT_Status;			// for further use
                     <      	.EXTERNAL  	F_SP_Set_INT_Vector;			// for further use
                     <      	.EXTERNAL	F_SP_Clear_INT_Vector;			// for further use
                     <      	
                     <      	.EXTERNAL	F_SP_Send_Out;					//
                     <      	.EXTERNAL	F_SP_Send_DAC1;					//
                     <      	.EXTERNAL	F_SP_Send_DAC2;					//
                     <      	.EXTERNAL	F_SP_Send_Two_DAC;				//
                     <      	.EXTERNAL	F_SP_Init_HW;					//
                     <      	
                     <      	.EXTERNAL	R_InterruptStatus;
                     <      	
                     <      	
                     <      	.EXTERNAL 	F_SP_RampUpDAC1;
                     <      	.EXTERNAL 	F_SP_RampDnDAC1;
                     <      	.EXTERNAL 	F_SP_RampUpDAC2;
                     <      	.EXTERNAL  	F_SP_RampDnDAC2;
                     <      	
                     <      	.EXTERNAL 	F_SP_InitQueue;
                     <      	.EXTERNAL 	F_SP_ReadQueue;
                     <      	.EXTERNAL 	F_SP_WriteQueue;
                     <      	.EXTERNAL 	F_SP_TestQueue;
                     <      	
                     <      	
                     <      	
                     <      	.EXTERNAL	F_SP_Get_ADC
                     <      	
                     <      	.EXTERNAL 	F_SP_Set_P_TimerA_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_TimerA_Data
                     <      	.EXTERNAL 	F_SP_Set_P_TimerB_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_TimerB_Data
                     <      	.EXTERNAL 	F_SP_Set_P_INT_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_INT_Clear
                     <      	.EXTERNAL 	F_SP_Set_P_SystemClock
                     <      	.EXTERNAL 	F_SP_Set_P_DAC_Ctrl
                     <      	.EXTERNAL 	F_SP_Set_P_ADC_Ctrl
                     <      	
                     <      		
                     <      	
                     <      	//--------------------------------------------
                     <      	SACM_MACRO1: 	.MACRO
                     <      		
                     <      		.ENDM
                     <      	
                     <      	SACM_MACRO2:	.MACRO
                     <      		
                     <      		.ENDM
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	//.define PC_Play_Enable_A2000		1    	// Enable the PC-Play function for SACM-A2000 module
                     <      	//.define PC_Play_Enable_S480		1    	// Enable the PC-Play function for SACM-S480 module
                     <      	//.define PC_Play_Enable_S240		1    	// Enable the PC-Play function for SACM-S240 module    
                     <      	//.define PC_Play_Enable_MS01		1    	// Enable the PC-Play function for SACM-MS01 module
                     <      	
                     <      	
                     <      	
                     <      	//========================================================================================        
                     <      	// End of hardware.inc
                     <      	//========================================================================================
                            	
                            	.DEFINE C_SIOCLOCK           0x0010;        // CPUCLOCK/8
                            	
0000C6F7                    	.CODE
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Send A Byte to Serial Flash
                            	// Syntax: SP_SIOSendAByte(AddressLow,AddressHigh,  data)
                            	// c level public
                            	// Used register: r1,r2,r3
                            	//////////////////////////////////////////////////////////////////
                            	.public _SP_SIOSendAByte;
                            	_SP_SIOSendAByte: .PROC
                            	F_SIOSendAByte:
0000C6F7 88 DA              	    PUSH BP,BP TO [SP];
0000C6F8 08 0B 01 00        	    BP = SP + 1;
0000C6FA 03 92              		R1 = [BP+3];
0000C6FB 19 D3 1B 70        	    [P_SIO_Addr_Low]=r1;        // input SFLASH low address
0000C6FD 79 93              	    r1=r1 lsr 4;         		// right shift 8
0000C6FE 79 93              	    r1=r1 lsr 4;
0000C6FF 19 D3 1C 70        	    [P_SIO_Addr_Mid]=r1; 		// input SFLASH mid address
0000C701 04 92              	    R1 = [BP+4];                // Port direction
0000C702 47 B2              	    r1=r1&0x0007;  				// input SFLASH hi address
0000C703 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
0000C705 09 93 D3 00        	        r1=0x00C3+C_SIOCLOCK;
0000C707 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;        // clk=CPUclk/8, 24 bit address  ;write
0000C709 19 D3 1F 70        	        [P_SIO_Start]=r1;       // enable write mode
0000C70B 05 92              	        R1 = [BP+5];
0000C70C 19 D3 1A 70        	        [P_SIO_Data]=r1;        // state to transmit data
                            	L_WaitSIOSendReady:
0000C70E 11 93 1F 70        	        r1=[P_SIO_Start];
0000C710 09 C3 80 00        	        test    r1,0x0080
0000C712 45 4E              	        jne     L_WaitSIOSendReady
0000C713 19 D3 20 70        	        [P_SIO_Stop]=r1;                   //disable write mode
0000C715 88 98              	        POP BP,BP FROM [SP];
0000C716 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Read A Byte to Serial Flash
                            	// Syntax: SP_SIOReadAByte(AddressLow, AddressHigh)
                            	// c level public
                            	// Used register: r1,r2,r3
                            	// Return register: r1
                            	//////////////////////////////////////////////////////////////////         
                            	
                            	.public _SP_SIOReadAByte;
                            	_SP_SIOReadAByte: .PROC
                            	F_SIOReadAByte:
0000C717 88 DA              	                PUSH BP,BP TO [SP];
0000C718 08 0B 01 00        	        BP = SP + 1;
0000C71A 03 92              	        R1 = [BP+3];
0000C71B 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 		// input SFLASH low address
0000C71D 79 93              	        r1=r1 lsr 4;
0000C71E 79 93              	        r1=r1 lsr 4;
0000C71F 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1; 		// input SFLASH mid address
0000C721 04 92              	        R1 = [BP+4];                // Port direction
0000C722 47 B2              	        r1=r1&0x0007;  				// input SFLASH hi address
0000C723 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
0000C725 09 93 93 00        	        r1=0x0083+C_SIOCLOCK;
0000C727 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;            // clk=CPUclk/16, 24 bit address  ;read
0000C729 19 D3 1F 70        	        [P_SIO_Start]=r1;           // enable read mode
0000C72B 12 95 1A 70        	        r2=[P_SIO_Data];            // Clear SFLASH buffer
                            	L_WaitSIOReadReady1:
0000C72D 11 93 1F 70        	        r1=[P_SIO_Start];
0000C72F 09 C3 80 00        	        test    r1,0x0080
0000C731 45 4E              	        jne     L_WaitSIOReadReady1
0000C732 11 93 1A 70        	        r1=[P_SIO_Data];          	// Read exact Data
                            	L_WaitSIOReadReady2:                // Wait read stop
0000C734 12 95 1F 70        	        r2=[P_SIO_Start];
0000C736 0A C5 80 00        	        test    r2,0x0080
0000C738 45 4E              	        jne     L_WaitSIOReadReady2
0000C739 1A D5 20 70        	        [P_SIO_Stop]=r2;            // disable read mode
0000C73B 88 98              	        POP BP,BP FROM [SP];
0000C73C 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Send A Word to Serial Flash
                            	// Syntax: SP_SIOSendAData(AddressLow,AddressHigh,  data) Address must be even
                            	// c level public
                            	// Used register: r1,r2,r3
                            	//////////////////////////////////////////////////////////////////
                            	.public _SP_SIOSendAWord;
                            	_SP_SIOSendAWord: .PROC
                            	F_SIOSendAWord:
0000C73D 88 DA              	        PUSH BP,BP TO [SP];
0000C73E 08 0B 01 00        	        BP = SP + 1;
                            	//        PUSH r1,r3 TO [SP];
0000C740 09 93 D3 00        	        r1=0x00C3+C_SIOCLOCK;
0000C742 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;            // clk=CPUclk/8, 24 bit address  ;write
0000C744 03 92              	        R1 = [BP+3];
0000C745 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1;  		// input Sflash low address
0000C747 79 93              	        r1=r1 lsr 4;          		// right shift 8
0000C748 79 93              	        r1=r1 lsr 4;
0000C749 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1;  		// input SFLASH mid address
0000C74B 04 92              	        R1 = [BP+4];                // Port direction
0000C74C 47 B2              	        r1=r1&0x0007;  				// input SFLASH hi address
0000C74D 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
                            	        
0000C74F 19 D3 1F 70        	        [P_SIO_Start]=r1;           // enable write mode
0000C751 05 92              	        R1 = [BP+5];
0000C752 19 D3 1A 70        	        [P_SIO_Data]=r1;            //start to transmit low byte
                            	L_WaitSIOSendReadyLB:
0000C754 11 93 1F 70        	        r1=[P_SIO_Start];
0000C756 09 C3 80 00        	        test    r1,0x0080
0000C758 45 4E              	        jne     L_WaitSIOSendReadyLB
0000C759 40 F0 0A C8        	        call    F_DelayPT           // Delay necessary for the writing   
0000C75B 40 F0 0A C8        	        call    F_DelayPT 
0000C75D 40 F0 0A C8        	        call    F_DelayPT 
0000C75F 40 F0 0A C8        	        call    F_DelayPT            //modify by abin
                            	     //   call    F_DelayPT            //modify by abin
                            	     //   call    F_DelayPT            //modify by abin
                            	        
0000C761 19 D3 20 70        	        [P_SIO_Stop]=r1;            // disable write mode
0000C763 03 92              	         R1 = [BP+3];
0000C764 41 02              	         r1+=1;
0000C765 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 		// input SFLASH low address
                            	             
0000C767 19 D3 1F 70        	        [P_SIO_Start]=r1;           //enable write mode
0000C769 05 92              	        r1=[BP+5]; 
0000C76A 79 93              	        r1=r1 lsr 4;         		// right shift 8
0000C76B 79 93              	        r1=r1 lsr 4;
0000C76C 19 D3 1A 70        	        [P_SIO_Data]=r1;            //start to transmit high byte
                            	L_WaitSIOSendReadyHB:
0000C76E 11 93 1F 70        	        r1=[P_SIO_Start];
0000C770 09 C3 80 00        	        test    r1,0x0080
0000C772 45 4E              	        jne     L_WaitSIOSendReadyHB
0000C773 40 F0 0A C8        	     	call    F_DelayPT          //modify by abin
0000C775 40 F0 0A C8        	      	call    F_DelayPT          //modify by abin
0000C777 40 F0 0A C8        	        call    F_DelayPT
0000C779 40 F0 0A C8        	        call    F_DelayPT
0000C77B 19 D3 20 70        	        [P_SIO_Stop]=r1;            //disable write mode
                            	//        POP r1,r3 FROM [SP];
0000C77D 88 98              	        POP BP,BP FROM [SP];
0000C77E 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: Read A Word from Serial Flash
                            	// Syntax: SP_SIOReadAWord(AddressLow, AddressHigh)
                            	// c level public
                            	// Used register: r1,r2,r3,r4
                            	// Return register: r1
                            	//////////////////////////////////////////////////////////////////         
                            	
                            	.public _SP_SIOReadAWord;
                            	_SP_SIOReadAWord: .PROC
                            	F_SIOReadAWord:
0000C77F 88 DA              	        PUSH BP,BP TO [SP];
0000C780 08 0B 01 00        	        BP = SP + 1;
                            	      //  PUSH r2,r4 TO [SP];   modify by 
0000C782 0C 99 FF 00        	        r4=0x00FF;
0000C784 03 92              	        R1 = [BP+3];
0000C785 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 		// input SFLASH low address
0000C787 79 93              	        r1=r1 lsr 4;
0000C788 79 93              	        r1=r1 lsr 4;
0000C789 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1; 		// input SFLASH mid address
0000C78B 04 92              	        R1 = [BP+4];                // Port direction
0000C78C 47 B2              	        r1=r1&0x0007;  				// input SFLASH hi address
0000C78D 19 D3 1D 70        	        [P_SIO_Addr_High]=r1;
                            	     //   r1=0x0083+C_SIOCLOCK;       // C_SIOCLOCK 0x0010
0000C78F 09 93 83 00        	        r1=0x0083;    //+C_SIOCLOCK;       // C_SIOCLOCK 0x0010
0000C791 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;           	// clk=CPUclk/16, 24 bit address  ;read
0000C793 19 D3 1F 70        	        [P_SIO_Start]=r1;       	// enable read mode
                            	        ////////
0000C795 12 95 1A 70        	        r2=[P_SIO_Data];          	// Clear SFLASH buffer
                            	        ////////
                            	L_WaitSIOReadReady1LB:
0000C797 11 93 1F 70        	        r1=[P_SIO_Start];
0000C799 09 C3 80 00        	        test    r1,0x0080
0000C79B 45 4E              	        jne     L_WaitSIOReadReady1LB
                            	        
                            	        
                            	        
0000C79C 14 B5 1A 70        	        r2=r4&[P_SIO_Data];          // Read exact Low Byte
                            	L_WaitSIOReadReady2LB:               // Wait read stop
0000C79E 11 93 1F 70        	        r1=[P_SIO_Start];
0000C7A0 09 C3 80 00        	        test    r1,0x0080
0000C7A2 45 4E              	        jne     L_WaitSIOReadReady2LB
                            	        
                            	        
0000C7A3 14 B7 1A 70        	        r3=r4&[P_SIO_Data];          // Read exact High Byte
                            	
                            	L_WaitSIOReadReady2HB:               // Wait read stop
0000C7A5 11 93 1F 70        	        r1=[P_SIO_Start];
0000C7A7 09 C3 80 00        	        test    r1,0x0080
0000C7A9 45 4E              	        jne     L_WaitSIOReadReady2HB
                            	       
0000C7AA 19 D3 20 70        	        [P_SIO_Stop]=r1;             // disable read mode
                            	 
0000C7AC 5B 97              	        r3=r3 lsl 4;     //shift left 8
0000C7AD 5B 93              	        r1=r3 lsl 4;
0000C7AE 02 A3              	        r1|=r2;         //return data
                            	       // POP r2,r4 FROM [SP];
0000C7AF 88 98              	        POP BP,BP FROM [SP];
0000C7B0 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Page Erase for S_Flash (Page Size 1K)
                            	// Syntax: SP_SIOPageErase(Page)
                            	// Used register: r1,r2
                            	///////////////////////////////////////////////////////////////
                            	.public _SP_SIOPageErase;
                            	_SP_SIOPageErase: .PROC
                            	F_SIOPageErase:
0000C7B1 88 DA              	                PUSH BP,BP TO [SP];
0000C7B2 08 0B 01 00        	        BP = SP + 1;
                            	 
0000C7B4 03 92              	        R1 = [BP+3];
0000C7B5 49 93              	        r1=r1 lsl 2;      		// 1K page size
0000C7B6 09 B3 FF 01        	        r1=r1&0x01FF;
0000C7B8 09 A3 00 80        	        r1=r1|0x8000;
0000C7BA 19 D3 1B 70        	        [P_SIO_Addr_Low]=r1; 	// input SFLASH low address ;for A15 and A10
0000C7BC 79 93              	        r1=r1 lsr 4;
0000C7BD 79 93              	        r1=r1 lsr 4;
0000C7BE 19 D3 1C 70        	        [P_SIO_Addr_Mid]=r1; 	// input SFLASH mid address ;for A16
0000C7C0 09 93 D0 00        	        r1=0x00C0+C_SIOCLOCK;
0000C7C2 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;        // clk=CPUclk/8, 16 bit address  ;write
0000C7C4 19 D3 1F 70        	        [P_SIO_Start]=r1;       // enable write mode
0000C7C6 40 92              	        r1=0;                   // A7~A0 = 0
0000C7C7 19 D3 1A 70        	        [P_SIO_Data]=r1;        // state to transmit data
                            	
                            	L_WaitSIOSendReadyPage:
0000C7C9 11 93 1F 70        	        r1=[P_SIO_Start];
0000C7CB 09 C3 80 00        	        test    r1,0x0080
0000C7CD 45 4E              	        jne     L_WaitSIOSendReadyPage
0000C7CE 19 D3 20 70        	        [P_SIO_Stop]=r1;         //disable write mode
                            	
0000C7D0 40 F0 FA C7        	        call    F_Delay11ms
                            	        
0000C7D2 88 98              	        POP BP,BP FROM [SP];
0000C7D3 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Mass Erase for S_Flash
                            	// Syntax: SIOMassErase()
                            	// Used register: r1,r2
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _SP_SIOMassErase;
                            	_SP_SIOMassErase: .PROC
                            	F_SIOMassErase:
0000C7D4 90 D4              	        push r1,r2 to [sp];
0000C7D5 09 93 D0 00        	        r1=0x00C0+C_SIOCLOCK;
0000C7D7 19 D3 1E 70        	        [P_SIO_Ctrl]=r1;            // clk=CPUclk/8, 16 bit address  ;write
0000C7D9 40 94              	        r2=0x0000;
0000C7DA 1A D5 1B 70        	        [P_SIO_Addr_Low]=r2; 		// input SFLASH low address
0000C7DC 0A 95 C0 00        	        r2=0x00C0;
0000C7DE 1A D5 1C 70        	        [P_SIO_Addr_Mid]=r2; 		// input SFLASH mid address
0000C7E0 0A 95 C0 00        	        r2=0x00C0;
0000C7E2 1A D5 1D 70        	       [P_SIO_Addr_High]=r2; 
                            	//        r1=0x00C0+C_SIOCLOCK;
                            	  //      [P_SIO_Ctrl]=r1;            // clk=CPUclk/8, 16 bit address  ;write
0000C7E4 19 D3 1F 70        	        [P_SIO_Start]=r1;           // enable write mode
0000C7E6 40 92              	        r1=0;                       // A7~A0 = 0
0000C7E7 19 D3 1A 70        	        [P_SIO_Data]=r1;            // state to transmit data
                            	
                            	L_WaitSIOSendReadyMass:
0000C7E9 11 93 1F 70        	        r1=[P_SIO_Start];
0000C7EB 09 C3 80 00        	        test    r1,0x0080
0000C7ED 45 4E              	        jne     L_WaitSIOSendReadyMass
                            	                      //disable write mode
0000C7EE 19 D3 20 70        			[P_SIO_Stop]=r1;
                            	
0000C7F0 40 F0 FA C7        	        call    F_Delay11ms
0000C7F2 40 F0 FA C7        	        call    F_Delay11ms      //modify by abin
0000C7F4 40 F0 FA C7        	        call    F_Delay11ms
0000C7F6 40 F0 FA C7        	        call    F_Delay11ms
0000C7F8 90 90              	        pop r1,r2 from [sp];
0000C7F9 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	F_Delay11ms:
0000C7FA 88 D2              	        push r1,r1 to [sp];
                            	        //r1=17*10;
0000C7FB 09 93 C8 00        	        r1=20*10;  // delay 
                            	L_LoopDelay11:
0000C7FD 40 F0 03 C8        	        call    F_Delay100uS;
0000C7FF 41 22              	        r1-=1;
0000C800 44 4E              	        jne     L_LoopDelay11
0000C801 88 90              	        pop r1,r1 from [sp];
0000C802 90 9A              	        retf;
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : 100us Dealy for S_Flash programming time (base on CPUCLK= 24MHz)
                            	// Syntax: Delay100uS()
                            	// Used register: r1,r2
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _Delay100uS;
                            	_Delay100uS: .PROC
                            	F_Delay100uS:  //13
0000C803 88 D2              	        push r1,r1 to [sp];             //7
0000C804 09 93 26 01        	        r1=294;  //6
                            	L_DelayLoop:
0000C806 41 22              	        r1-=1;  //3           26+19+8*294 =2400
0000C807 42 4E              	        jne     L_DelayLoop;   //5
0000C808 88 90              	        pop r1,r1 from [sp];    //7
0000C809 90 9A              	        retf;      //12
                            	        .ENDP;
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Dealy for S_Flash programming time (base on CPUCLK= 24MHz)
                            	// Syntax: DelayPT()
                            	// Used register: r1
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _DelayPT;
                            	_DelayPT: .PROC
                            	F_DelayPT:  //13
0000C80A 88 D2              	        push r1,r1 to [sp];             //7
                            	        //r1=294;  //6
                            	        //r1=147;
                            	        //r1=1600;
                            	        //r1=100;
0000C80B 09 93 A0 00        	        r1=160
                            	        //r1=200;
                            	L_DelayLoopPT:
0000C80D 41 22              	        r1-=1;  //3           26+19+8*160 =1325  ----> 56us
0000C80E 42 4E              	        jne     L_DelayLoopPT;   //5
0000C80F 88 90              	        pop r1,r1 from [sp];    //7
0000C810 90 9A              	        retf;      //12
                            	        .ENDP;
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Write head. There are 8 bytes. The first 4 bytes is address of ending speech
                            	//           The last 4 bytes is 1' complement of first 4 bytes
                            	// Syntax  : SP_WriteHeader( Low Address of header, High Address of header, DataLow, DataHigh)
                            	// Used register: r1-r3
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _SP_WriteHeader;
                            	_SP_WriteHeader: .PROC
                            	F_WriteHeader:
0000C811 88 DA              	        PUSH BP,BP TO [SP];
0000C812 08 0B 01 00        	        BP = SP + 1;
0000C814 05 96              	        r3=[BP+5];  //data for programming
0000C815 04 94              	        r2=[BP+4];  //high addr for programming
0000C816 03 92              	        r1=[BP+3];  //low addr for programming
0000C817 98 D6              	        PUSH r1,r3 TO [SP];
0000C818 40 F0 3D C7        	        call    F_SIOSendAWord;
0000C81A 98 90              	        pop r1,r3 from [SP];
0000C81B 06 96              	        r3=[BP+6];  //data for programming
0000C81C 04 94              	        r2=[BP+4];  //high addr for programming
0000C81D 03 92              	        r1=[BP+3];  //low addr for programming
0000C81E 42 02              	        r1+=2;
0000C81F 40 14              	        r2+=0, carry;
0000C820 98 D6              	        PUSH r1,r3 TO [SP];
0000C821 40 F0 3D C7        	        call    F_SIOSendAWord;
0000C823 98 90              	        pop r1,r3 from [SP];
0000C824 05 96              	        r3=[BP+5];  //data for programming
0000C825 0B 87 FF FF        	        r3^=0xffff;
0000C827 04 94              	        r2=[BP+4];  //high addr for programming
0000C828 03 92              	        r1=[BP+3];  //low addr for programming
0000C829 44 02              	        r1+=4;
0000C82A 40 14              	        r2+=0, carry;
0000C82B 98 D6              	        PUSH r1,r3 TO [SP];
0000C82C 40 F0 3D C7        	        call    F_SIOSendAWord;
0000C82E 98 90              	        pop r1,r3 from [SP];
0000C82F 06 96              	        r3=[BP+6];  //data for programming
0000C830 0B 87 FF FF        	        r3^=0xffff;
0000C832 04 94              	        r2=[BP+4];  //high addr for programming
0000C833 03 92              	        r1=[BP+3];  //low addr for programming
0000C834 46 02              	        r1+=6;
0000C835 40 14              	        r2+=0, carry;
0000C836 98 D6              	        PUSH r1,r3 TO [SP];
0000C837 40 F0 3D C7        	        call    F_SIOSendAWord;
0000C839 98 90              	        pop r1,r3 from [SP];
0000C83A 88 98              	        POP BP,BP FROM [SP];
0000C83B 90 9A              	        retf;
                            	        .ENDP;
                            	
                            	
                            	
                            	///////////////////////////////////////////////////////////////
                            	//Function : Check header. Header has 8 bytes. The first 4 bytes is address of ending speech
                            	//           The last 4 bytes is 1' complement of first 4 bytes
                            	// Syntax  : CheckHeader( Low Address of header, High Address of header)
                            	// Used register: r1
                            	// return value : r1, r2  (if r1=0xffff and r2=0xffff, error)
                            	///////////////////////////////////////////////////////////////
                            	
                            	.public _SP_CheckHeader;
                            	_SP_CheckHeader: .PROC
                            	F_CheckHeader:
0000C83C 88 DA              	        PUSH BP,BP TO [SP];
0000C83D 08 0B 01 00        	        BP = SP + 1;
0000C83F 04 96              	        r3=[BP+4];  //high addr for reading
0000C840 03 94              	        r2=[BP+3];  //low addr for reading
0000C841 42 04              	        r2+=2;
0000C842 40 16              	        r3+=0, carry;
0000C843 98 D8              	        PUSH r2,r4 TO [SP];
0000C844 40 F0 7F C7        	        call    F_SIOReadAWord;
0000C846 98 92              	        pop r2,r4 from [SP];
0000C847 01 99              	        r4=r1;
0000C848 04 96              	        r3=[BP+4];  //high addr for reading
0000C849 03 94              	        r2=[BP+3];  //low addr for reading
0000C84A 46 04              	        r2+=6;
0000C84B 40 16              	        r3+=0, carry;
0000C84C 98 D8              	        PUSH r2,r4 TO [SP];
0000C84D 40 F0 7F C7        	        call    F_SIOReadAWord;
0000C84F 98 92              	        pop r2,r4 from [SP];
0000C850 09 83 FF FF        	        r1^=0xffff;
0000C852 04 43              	        cmp r1,r4
0000C853 18 4E              	        jne L_HeaderError
0000C854 88 D8              	        PUSH r4,r4 TO [SP];     //save high byte of return data
0000C855 04 96              	        r3=[BP+4];  //high addr for reading
0000C856 03 94              	        r2=[BP+3];  //low addr for reading
0000C857 98 D8              	        PUSH r2,r4 TO [SP];
0000C858 40 F0 7F C7        	        call    F_SIOReadAWord;
0000C85A 98 92              	        pop r2,r4 from [SP];
0000C85B 01 99              	        r4=r1;
0000C85C 04 96              	        r3=[BP+4];  //high addr for reading
0000C85D 03 94              	        r2=[BP+3];  //low addr for reading
0000C85E 44 04              	        r2+=4;
0000C85F 40 16              	        r3+=0, carry;
0000C860 98 D8              	        PUSH r2,r4 TO [SP];
0000C861 40 F0 7F C7        	        call    F_SIOReadAWord;
0000C863 98 92              	        pop r2,r4 from [SP];
0000C864 09 83 FF FF        	        r1^=0xffff;
0000C866 04 43              	        cmp r1,r4
0000C867 03 4E              	        jne  L_HeaderError2
0000C868 88 92              	        POP r2,r2 FROM [SP];     //get high byte of return data
0000C869 88 98              	        POP BP,BP FROM [SP];
0000C86A 90 9A              	        retf;
                            	
                            	L_HeaderError2:
0000C86B 88 96              	        POP r4,r4 FROM [SP];     //remove high byte of return data
                            	
                            	L_HeaderError:
0000C86C 09 93 FF FF        	        r1=0xffff;
0000C86E 0A 95 FF FF        	        r2=0xffff;
0000C870 88 98              	        POP BP,BP FROM [SP];
                            	        .ENDP;
                            	
                            	
                            	
                            	
0 error(s), 0 warning(s).










